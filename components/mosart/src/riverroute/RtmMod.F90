module RtmMod

!-----------------------------------------------------------------------
!BOP
!
! !MODULE: RtmMod
!
! !DESCRIPTION:
! Mosart Routing Model
!
! !USES:
  use shr_kind_mod    , only : r8 => shr_kind_r8
  use shr_sys_mod     , only : shr_sys_flush
  use shr_const_mod   , only : SHR_CONST_PI, SHR_CONST_CDAY
  use rof_cpl_indices , only : nt_rtm, rtm_tracers 
  use RtmSpmd         , only : masterproc, npes, iam, mpicom_rof, ROFID, &
                               MPI_REAL8,MPI_INTEGER,MPI_CHARACTER,MPI_LOGICAL,MPI_MAX
  use RtmVar          , only : re, spval, rtmlon, rtmlat, iulog, ice_runoff, &
                               frivinp_rtm, finidat_rtm, nrevsn_rtm, &
                               nsrContinue, nsrBranch, nsrStartup, nsrest, &
                               inst_index, inst_suffix, inst_name
  use RtmFileUtils    , only : getfil, getavu, relavu
  use RtmTimeManager  , only : timemgr_init, get_nstep, get_curr_date
  use RtmHistFlds     , only : RtmHistFldsInit, RtmHistFldsSet 
  use RtmHistFile     , only : RtmHistUpdateHbuf, RtmHistHtapesWrapup, RtmHistHtapesBuild, &
                               rtmhist_ndens, rtmhist_mfilt, rtmhist_nhtfrq,     &
                               rtmhist_avgflag_pertape, rtmhist_avgflag_pertape, & 
                               rtmhist_fincl1, rtmhist_fincl2, rtmhist_fincl3,   &
                               rtmhist_fexcl1, rtmhist_fexcl2, rtmhist_fexcl3,   &
                               max_tapes, max_namlen
  use RtmRestFile     , only : RtmRestTimeManager, RtmRestGetFile, RtmRestFileRead, &
                               RtmRestFileWrite, RtmRestFileName
  use RunoffMod       , only : RunoffInit, rtmCTL, Tctl, Tunit, TRunoff, Tpara
  use MOSART_physics_mod
  use RtmIO
  use mct_mod
  use perf_mod
  use pio
!
! !PUBLIC TYPES:
  implicit none
  private
!
! !PUBLIC MEMBER FUNCTIONS:
  public Rtmini          ! Initialize RTM grid
  public Rtmrun          ! River routing model
!
! !REVISION HISTORY:
! Author: Sam Levis
!
! !PRIVATE MEMBER FUNCTIONS:
  private :: RtmFloodInit

! !PRIVATE TYPES:

! RTM tracers
  character(len=256) :: rtm_trstr   ! tracer string

! RTM naemlists
  integer, save :: rtm_tstep              ! RTM time step

! RTM constants
  real(r8),save :: delt_rtm_max     ! RTM max timestep
  real(r8) :: cfl_scale = 0.1_r8    ! cfl scale factor, must be <= 1.0

!global (glo)
  integer , pointer :: dwnstrm_index(:)! downstream index

!local (gdc)
  real(r8), save, pointer :: ddist(:)        ! downstream dist (m)
  real(r8), save, pointer :: evel(:,:)       ! effective tracer velocity (m/s)
  real(r8), save, pointer :: sfluxin(:,:)    ! cell tracer influx (m3/s)
  real(r8), save, pointer :: fluxout(:,:)    ! cell tracer outlflux (m3/s)

! global rtm grid
  real(r8),pointer :: rlatc(:)    ! latitude of 1d grid cell (deg)
  real(r8),pointer :: rlonc(:)    ! longitude of 1d grid cell (deg)
  real(r8),pointer :: rlats(:)    ! latitude of 1d south grid cell edge (deg)
  real(r8),pointer :: rlatn(:)    ! latitude of 1d north grid cell edge (deg)
  real(r8),pointer :: rlonw(:)    ! longitude of 1d west grid cell edge (deg)
  real(r8),pointer :: rlone(:)    ! longitude of 1d east grid cell edge (deg)

  logical :: do_rtmflood
  logical :: do_rtm

  type(mct_sMatP)  :: sMatP       ! sparse matrix plus for SM mult
  type(mct_avect)  :: avsrc       ! avect for SM mult
  type(mct_avect)  :: avdst       ! avect for SM mult

  character(len=256) :: nlfilename_rof = 'mosart_in' 
!
!EOP
!-----------------------------------------------------------------------

contains

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Rtmini
!
! !INTERFACE:
  subroutine Rtmini(rtm_active,flood_active)
!
! !DESCRIPTION:
! Initialize RTM grid, mask, decomp
!
! !USES:
!
! !ARGUMENTS:
    implicit none
    logical, intent(out) :: rtm_active
    logical, intent(out) :: flood_active
!
! !CALLED FROM:
! subroutine initialize in module initializeMod
!
! !REVISION HISTORY:
! Author: Sam Levis
! Update: T Craig, Dec 2006
!
!
! !LOCAL VARIABLES:
!EOP
    real(r8) :: effvel0 = 0.35_r8             ! default velocity
    real(r8) :: effvel(nt_rtm)                ! downstream velocity (m/s)
    real(r8) :: edgen                         ! North edge of the direction file
    real(r8) :: edgee                         ! East edge of the direction file
    real(r8) :: edges                         ! South edge of the direction file
    real(r8) :: edgew                         ! West edge of the direction file
    integer  :: i,j,k,n,ng,g,n2,nt,nn         ! loop indices
    integer  :: im1,ip1,jm1,jp1,ir,jr,nr      ! neighbor indices
    real(r8) :: deg2rad                       ! pi/180
    real(r8) :: dx,dx1,dx2,dx3                ! lon dist. betn grid cells (m)
    real(r8) :: dy                            ! lat dist. betn grid cells (m)
    real(r8) :: lrtmarea                      ! tmp local sum of area
    real(r8),allocatable :: tempr(:,:)        ! temporary buffer
    integer ,allocatable :: itempr(:,:)       ! temporary buffer
    integer ,allocatable :: rdirc(:)          ! temporary buffer
    integer ,allocatable :: idxocn(:)         ! downstream ocean cell
    integer ,allocatable :: nupstrm(:)        ! number of rtm cells in basin
    integer ,allocatable :: pocn(:)           ! pe number assigned to basin
    integer ,allocatable :: nop(:)            ! number of rtm cells on a pe
    integer ,allocatable :: nba(:)            ! number of basins on each pe
    integer ,allocatable :: nrs(:)            ! begr on each pe
    integer ,allocatable :: basin(:)          ! basin to rtm mapping
    integer  :: nbas,nbas_chk                 ! number of basins
    integer  :: nrof,nrof_chk                 ! num of active rtm points
    integer  :: baspe                         ! pe with min number of rtm cells
    integer  :: maxrtm                        ! max num of rtms per pe for decomp
    integer  :: minbas,maxbas                 ! used for decomp search
    integer  :: nl,nloops                     ! used for decomp search
    integer  :: ier                           ! error code
    integer  :: mon                           ! month (1, ..., 12)
    integer  :: day                           ! day of month (1, ..., 31)
    integer  :: numr                          ! tot num of roff pts on all pes
    real(r8) :: dtover,dtovermax              ! ts calc temporaries
    type(file_desc_t) :: ncid                 ! netcdf file id
    integer  :: dimid                         ! netcdf dimension identifier
    integer  :: nroflnd                       ! local number of land runoff 
    integer  :: nrofocn                       ! local number of ocn runoff
    integer  :: pid,np,npmin,npmax,npint      ! log loop control
    integer  :: na,nb,ns                      ! mct sizes
    integer  :: ni,no,go                      ! tmps
    integer ,pointer  :: rgdc2glo(:)          ! temporary for initialization
    integer ,pointer  :: rglo2gdc(:)          ! temporary for initialization
    integer ,pointer  :: gmask(:)             ! global mask
    logical           :: found                ! if variable found on rdirc file
    character(len=256):: fnamer               ! name of netcdf restart file 
    character(len=256):: pnamer               ! full pathname of netcdf restart file
    character(len=256):: locfn                ! local file name
    character(len=32) :: decomp_option        ! decomp option
    integer           :: unitn                ! unit for namelist file
    integer,parameter :: dbug = 3             ! 0 = none, 1=normal, 2=much, 3=max
    logical :: lexist                         ! File exists
    character(len= 7) :: runtyp(4)            ! run type
    integer ,allocatable :: gindex(:)         ! global index
    integer           :: cnt, lsize, gsize    ! counter
    integer           :: igrow,igcol,iwgt     ! mct field indices
    type(mct_sMat)    :: sMat                 ! temporary sparse matrix, needed for sMatP
    type(mct_gsmap)   :: gsmap_r              ! temporary global seg map, needed for sMatP
    character(*),parameter :: subname = '(Rtmini) '
!-----------------------------------------------------------------------

    !-------------------------------------------------------
    ! Read in rtm namelist
    !-------------------------------------------------------

    namelist /mosart_inparm / ice_runoff, do_rtm, do_rtmflood, &
         frivinp_rtm, finidat_rtm, nrevsn_rtm, rtm_tstep, &
         rtmhist_ndens, rtmhist_mfilt, rtmhist_nhtfrq, &
         rtmhist_fincl1,  rtmhist_fincl2, rtmhist_fincl3, &
         rtmhist_fexcl1,  rtmhist_fexcl2, rtmhist_fexcl3, &
         rtmhist_avgflag_pertape, decomp_option

    ! Preset values
    do_rtm      = .true.
    do_rtmflood = .false.
    ice_runoff  = .true.
    finidat_rtm = ' '
    nrevsn_rtm  = ' '
    rtm_tstep   = -1
    decomp_option = 'basin'

    nlfilename_rof = "mosart_in" // trim(inst_suffix)
    inquire (file = trim(nlfilename_rof), exist = lexist)
    if ( .not. lexist ) then
       write(iulog,*) subname // ' ERROR: nlfilename_rof does NOT exist:'&
            //trim(nlfilename_rof)
       call shr_sys_abort(trim(subname)//' ERROR nlfilename_rof does not exist')
    end if
    if (masterproc) then
       unitn = getavu()
       write(iulog,*) 'Read in mosart_inparm namelist from: ', trim(nlfilename_rof)
       open( unitn, file=trim(nlfilename_rof), status='old' )
       ier = 1
       do while ( ier /= 0 )
          read(unitn, mosart_inparm, iostat=ier)
          if (ier < 0) then
             call shr_sys_abort( subname//' encountered end-of-file on mosart_inparm read' )
          endif
       end do
       call relavu( unitn )
    end if

    call mpi_bcast (rtm_tstep,   1, MPI_INTEGER, 0, mpicom_rof, ier)

    call mpi_bcast (finidat_rtm  , len(finidat_rtm)  , MPI_CHARACTER, 0, mpicom_rof, ier)
    call mpi_bcast (frivinp_rtm  , len(frivinp_rtm)  , MPI_CHARACTER, 0, mpicom_rof, ier)
    call mpi_bcast (nrevsn_rtm   , len(nrevsn_rtm)   , MPI_CHARACTER, 0, mpicom_rof, ier)
    call mpi_bcast (decomp_option, len(decomp_option), MPI_CHARACTER, 0, mpicom_rof, ier)

    call mpi_bcast (do_rtm,      1, MPI_LOGICAL, 0, mpicom_rof, ier)
    call mpi_bcast (do_rtmflood, 1, MPI_LOGICAL, 0, mpicom_rof, ier)
    call mpi_bcast (ice_runoff,  1, MPI_LOGICAL, 0, mpicom_rof, ier)

    call mpi_bcast (rtmhist_nhtfrq, size(rtmhist_nhtfrq), MPI_INTEGER,   0, mpicom_rof, ier)
    call mpi_bcast (rtmhist_mfilt , size(rtmhist_mfilt) , MPI_INTEGER,   0, mpicom_rof, ier)
    call mpi_bcast (rtmhist_ndens , size(rtmhist_ndens) , MPI_INTEGER,   0, mpicom_rof, ier)

    call mpi_bcast (rtmhist_fexcl1, (max_namlen+2)*size(rtmhist_fexcl1), MPI_CHARACTER, 0, mpicom_rof, ier)
    call mpi_bcast (rtmhist_fexcl2, (max_namlen+2)*size(rtmhist_fexcl2), MPI_CHARACTER, 0, mpicom_rof, ier)
    call mpi_bcast (rtmhist_fexcl3, (max_namlen+2)*size(rtmhist_fexcl3), MPI_CHARACTER, 0, mpicom_rof, ier)
    call mpi_bcast (rtmhist_fincl1, (max_namlen+2)*size(rtmhist_fincl1), MPI_CHARACTER, 0, mpicom_rof, ier)
    call mpi_bcast (rtmhist_fincl2, (max_namlen+2)*size(rtmhist_fincl2), MPI_CHARACTER, 0, mpicom_rof, ier)
    call mpi_bcast (rtmhist_fincl3, (max_namlen+2)*size(rtmhist_fincl3), MPI_CHARACTER, 0, mpicom_rof, ier)

    call mpi_bcast (rtmhist_avgflag_pertape, size(rtmhist_avgflag_pertape), MPI_CHARACTER, 0, mpicom_rof, ier)

    runtyp(:)               = 'missing'
    runtyp(nsrStartup  + 1) = 'initial'
    runtyp(nsrContinue + 1) = 'restart'
    runtyp(nsrBranch   + 1) = 'branch '

    if (masterproc) then
       write(iulog,*) 'define run:'
       write(iulog,*) '   run type              = ',runtyp(nsrest+1)
       !write(iulog,*) '   case title            = ',trim(ctitle)
       !write(iulog,*) '   username              = ',trim(username)
       !write(iulog,*) '   hostname              = ',trim(hostname)
       if (nsrest == nsrStartup .and. finidat_rtm /= ' ') then
          write(iulog,*) '   MOSART initial data   = ',trim(finidat_rtm)
       end if
    endif

    rtm_active = do_rtm
    flood_active = do_rtmflood
    
    if (do_rtm) then
       if (frivinp_rtm == ' ') then
          call shr_sys_abort( subname//' ERROR: do_rtm TRUE, but frivinp_rtm NOT set' )
       else
          if (masterproc) then
             write(iulog,*) '   MOSART river data       = ',trim(frivinp_rtm)
          endif
       end if
    else
       if (masterproc) then
          write(iulog,*)'MOSART will not be active '
       endif
       RETURN
    end if

    if (rtm_tstep <= 0) then
       write(iulog,*) subname,': ERROR MOSART step invalid',rtm_tstep
       call shr_sys_abort( subname//' ERROR: rtm_tstep invalid' )
    endif
       
    do i = 1, max_tapes
       if (rtmhist_nhtfrq(i) == 0) then
          rtmhist_mfilt(i) = 1
       else if (rtmhist_nhtfrq(i) < 0) then
          rtmhist_nhtfrq(i) = nint(-rtmhist_nhtfrq(i)*SHR_CONST_CDAY/(24._r8*rtm_tstep))
       endif
    end do

    !-------------------------------------------------------
    ! Initialize rtm time manager 
    !-------------------------------------------------------

    ! Intiialize RTM pio
    call ncd_pio_init()

    ! Obtain restart file if appropriate
    if ((nsrest == nsrStartup .and. finidat_rtm /= ' ') .or. &
        (nsrest == nsrContinue) .or. & 
        (nsrest == nsrBranch  )) then
       call RtmRestGetfile( file=fnamer, path=pnamer )
    endif       

    ! Initialize time manager
    if (nsrest == nsrStartup) then  
       call timemgr_init(dtime_in=rtm_tstep)
    else
       call RtmRestTimeManager(file=fnamer)
    end if

    !-------------------------------------------------------
    ! Initialize rtm_trstr
    !-------------------------------------------------------

    rtm_trstr = trim(rtm_tracers(1))
    do n = 2,nt_rtm
       rtm_trstr = trim(rtm_trstr)//':'//trim(rtm_tracers(n))
    enddo
    if (masterproc) then
       write(iulog,*)'MOSART tracers = ',nt_rtm,trim(rtm_trstr)
    end if

    !-------------------------------------------------------
    ! Read input data (river direction file)
    !-------------------------------------------------------

    ! Useful constants and initial values
    deg2rad = SHR_CONST_PI / 180._r8

    call t_startf('mosarti_grid')

    call getfil(frivinp_rtm, locfn, 0 )
    if (masterproc) then
       write(iulog,*)'Read in MOSART file name: ',trim(frivinp_rtm)
       call shr_sys_flush(iulog)
    endif

    call ncd_pio_openfile (ncid, trim(locfn), 0)
    call ncd_inqdid(ncid,'lon',dimid)
    call ncd_inqdlen(ncid,dimid,rtmlon)
    call ncd_inqdid(ncid,'lat',dimid)
    call ncd_inqdlen(ncid,dimid,rtmlat)

    if (masterproc) then
       write(iulog,*) 'Values for rtmlon/rtmlat: ',rtmlon,rtmlat
       write(iulog,*) 'Successfully read MOSART dimensions'
       call shr_sys_flush(iulog)
    endif

    ! Allocate variables
    allocate(rlonc(rtmlon), rlatc(rtmlat), &
             rlonw(rtmlon), rlone(rtmlon), &
             rlats(rtmlat), rlatn(rtmlat), &
             rtmCTL%rlon(rtmlon),          &
             rtmCTL%rlat(rtmlat),          &
             rdirc(rtmlon*rtmlat),         &
             stat=ier)
    if (ier /= 0) then
       write(iulog,*)'Rtmgridini: Allocation ERROR for rdirc'
       call shr_sys_abort('Rtmgridinit ERROR alloc for rdirc')
    end if

    allocate (dwnstrm_index(rtmlon*rtmlat), stat=ier)
    if (ier /= 0) then
       write(iulog,*)'Rtmgridini: Allocation ERROR for dwnstrm_index'
       call shr_sys_abort('Rtmgridinit ERROR alloc for dwnstrm_index')
    end if

    ! reading the routing parameters
    allocate (TUnit%fdir(rtmlon*rtmlat), &
              TUnit%ID0(rtmlon*rtmlat), TUnit%area(rtmlon*rtmlat), &
              TUnit%dnID(rtmlon*rtmlat),TUnit%rlen(rtmlon*rtmlat), &
              stat=ier)
    if (ier /= 0) then
       write(iulog,*)'Rtmgridini: Allocation error for TUnit%fdir'
       call shr_sys_abort('Rtmgridinit ERROR alloc for fdir')
    end if

    allocate(tempr(rtmlon,rtmlat))  
    allocate(itempr(rtmlon,rtmlat))  

    call ncd_io(ncid=ncid, varname='longxy', flag='read', data=tempr, readvar=found)
    if ( .not. found ) call shr_sys_abort( trim(subname)//' ERROR: read RTM longitudes')
    if (masterproc) write(iulog,*) 'Read longxy ',minval(tempr),maxval(tempr)
    do i=1,rtmlon
       rtmCTL%rlon(i) = tempr(i,1)
       rlonc(i) = tempr(i,1)
    enddo
    if (masterproc) write(iulog,*) 'rlonc ',minval(rlonc),maxval(rlonc)

    call ncd_io(ncid=ncid, varname='latixy', flag='read', data=tempr, readvar=found)
    if ( .not. found ) call shr_sys_abort( trim(subname)//' ERROR: read RTM latitudes')
    if (masterproc) write(iulog,*) 'Read latixy ',minval(tempr),maxval(tempr)
    do j=1,rtmlat
       rtmCTL%rlat(j) = tempr(1,j)
       rlatc(j) = tempr(1,j)
    end do
    if (masterproc) write(iulog,*) 'rlatc ',minval(rlatc),maxval(rlatc)

    call ncd_io(ncid=ncid, varname='fdir', flag='read', data=itempr, readvar=found)
    if ( .not. found ) call shr_sys_abort( trim(subname)//' ERROR: read RTM fdir')
    if (masterproc) write(iulog,*) 'Read fdir ',minval(itempr),maxval(itempr)
    do j=1,rtmlat
    do i=1,rtmlon
       n = (j-1)*rtmlon + i
       TUnit%fdir(n) = itempr(i,j)
       rdirc(n) = Tunit%fdir(n)
    end do
    end do
    if (masterproc) write(iulog,*) 'rdirc ',minval(rdirc),maxval(rdirc)

    call ncd_io(ncid=ncid, varname='ID', flag='read', data=itempr, readvar=found)
    if ( .not. found ) call shr_sys_abort( trim(subname)//' ERROR: read RTM ID')
    if (masterproc) write(iulog,*) 'Read ID ',minval(itempr),maxval(itempr)
    do j=1,rtmlat
    do i=1,rtmlon
       n = (j-1)*rtmlon + i
       TUnit%ID0(n) = itempr(i,j)
    end do
    end do
    if (masterproc) write(iulog,*) 'ID ',minval(itempr),maxval(itempr)

    call ncd_io(ncid=ncid, varname='area', flag='read', data=tempr, readvar=found)
    if ( .not. found ) call shr_sys_abort( trim(subname)//' ERROR: read RTM area')
    if (masterproc) write(iulog,*) 'Read area ',minval(tempr),maxval(tempr)
    do j=1,rtmlat
    do i=1,rtmlon
       n = (j-1)*rtmlon + i
       TUnit%area(n) = tempr(i,j)
    end do
    end do
    if (masterproc) write(iulog,*) 'area ',minval(tempr),maxval(tempr)

    call ncd_io(ncid=ncid, varname='rlen', flag='read', data=tempr, readvar=found)
    if ( .not. found ) call shr_sys_abort( trim(subname)//' ERROR: read RTM rlen')
    if (masterproc) write(iulog,*) 'Read rlen ',minval(tempr),maxval(tempr)
    do j=1,rtmlat
    do i=1,rtmlon
       n = (j-1)*rtmlon + i
       TUnit%rlen(n) = tempr(i,j)
    end do
    end do
    if (masterproc) write(iulog,*) 'rlen ',minval(tempr),maxval(tempr)

    call ncd_io(ncid=ncid, varname='dnID', flag='read', data=itempr, readvar=found)
    if ( .not. found ) call shr_sys_abort( trim(subname)//' ERROR: read RTM dnID')
    if (masterproc) write(iulog,*) 'Read dnID ',minval(itempr),maxval(itempr)
    do j=1,rtmlat
    do i=1,rtmlon
       n = (j-1)*rtmlon + i
       TUnit%dnID(n) = itempr(i,j)
       dwnstrm_index(n) = TUnit%dnID(n)
    end do
    end do
    if (masterproc) write(iulog,*) 'dnID ',minval(itempr),maxval(itempr)

    deallocate(tempr)
    deallocate(itempr)             

    call ncd_pio_closefile(ncid)

    !-------------------------------------------------------
    ! Derive gridbox edges
    !-------------------------------------------------------

    ! assuming equispaced grid, calculate edges from rtmlat/rtmlon
    ! w/o assuming a global grid
    edgen = maxval(rlatc) + 0.5*abs(rlatc(1) - rlatc(2))
    edges = minval(rlatc) - 0.5*abs(rlatc(1) - rlatc(2))
    edgee = maxval(rlonc) + 0.5*abs(rlonc(1) - rlonc(2))
    edgew = minval(rlonc) - 0.5*abs(rlonc(1) - rlonc(2))

    if ( edgen .ne.  90._r8 )then
       write(iulog,*) 'Regional grid: edgen = ', edgen
    end if
    if ( edges .ne. -90._r8 )then
       write(iulog,*) 'Regional grid: edges = ', edges
    end if
    if ( edgee .ne. 180._r8 )then
       write(iulog,*) 'Regional grid: edgee = ', edgee
    end if
    if ( edgew .ne.-180._r8 )then
       write(iulog,*) 'Regional grid: edgew = ', edgew
    end if

    ! Set edge latitudes (assumes latitudes are constant for a given longitude)
    rlats(:) = edges
    rlatn(:) = edgen
    do j = 2, rtmlat
       if (rlatc(2) > rlatc(1)) then ! South to North grid
          rlats(j)   = (rlatc(j-1) + rlatc(j)) / 2._r8
          rlatn(j-1) = rlats(j)
       else  ! North to South grid
          rlatn(j)   = (rlatc(j-1) + rlatc(j)) / 2._r8
          rlats(j-1) = rlatn(j)
       end if
    end do

!    if (masterproc) then
!       write(iulog,*) 'tcx rlats = ',rlats
!       write(iulog,*) 'tcx rlatn = ',rlatn
!    endif

    ! Set edge longitudes
    rlonw(:) = edgew
    rlone(:) = edgee
    dx = (edgee - edgew) / rtmlon
    do i = 2, rtmlon
       rlonw(i)   = rlonw(i) + (i-1)*dx
       rlone(i-1) = rlonw(i)
    end do

!    if (masterproc) then
!       write(iulog,*) 'tcx rlonw = ',rlonw
!       write(iulog,*) 'tcx rlone = ',rlone
!    endif

    !-------------------------------------------------------
    ! Determine rtm ocn/land mask (global, all procs)
    !-------------------------------------------------------

    !  0=none, 
    !  1=land, 
    !  2=ocean outflow, 
    ! -1=reroute over ocean to ocean outflow points

    call t_startf('mosarti_decomp')

    allocate (gmask(rtmlon*rtmlat), stat=ier)
    if (ier /= 0) then
       write(iulog,*)'Rtmgridini: Allocation ERROR for gmask'
       call shr_sys_abort('Rtmgridinit ERROR alloc for gmask')
    end if

    ! Initialize gmask to 2 everywhere, then compute land cells

    gmask = 2    ! assume ocean point

    do n=1,rtmlon*rtmlat         ! override downstream setting from local info
       nr = dwnstrm_index(n)
       if ((nr .gt. 0) .and. (nr .le. rtmlon*rtmlat)) then  ! n is always land if dwnstrm_index exists
          if (rdirc(n) > 0) then
             gmask(n) = 1
          else if (rdirc(n) < 0) then
             gmask(n) = -1
          end if
       end if
    enddo

    deallocate(rdirc)

    !-------------------------------------------------------
    ! Compute total number of basins and runoff points
    !-------------------------------------------------------

    nbas = 0
    nrof = 0
    do nr=1,rtmlon*rtmlat
       if (gmask(nr) == 2) then
          nbas = nbas + 1
       endif
       if (gmask(nr) == 1 .or. gmask(nr) == 2) then
          nrof = nrof + 1
       endif
    enddo

    !-------------------------------------------------------
    ! Compute river basins, actually compute ocean outlet gridcell
    !-------------------------------------------------------

    ! idxocn = final downstream cell, index is global 1d ocean gridcell
    ! nupstrm = number of source gridcells upstream including self

    allocate(idxocn(rtmlon*rtmlat),nupstrm(rtmlon*rtmlat),stat=ier)
    if (ier /= 0) then
       write(iulog,*)'Rtmgridini: Allocation ERROR for ',&
            'idxocn,nupstrm'
       call shr_sys_abort('Rtmgridinit ERROR alloc for idxocn nupstrm')
    end if

    call t_startf('mosarti_dec_basins')
    idxocn  = 0
    nupstrm = 0
    do nr=1,rtmlon*rtmlat
       n = nr
       if (abs(gmask(n)) == 1) then    ! land
          g = 0
          do while (abs(gmask(n)) == 1 .and. g < rtmlon*rtmlat)  ! follow downstream
             nupstrm(n) = nupstrm(n) + 1
             n = dwnstrm_index(n)
             g = g + 1
          end do
          if (gmask(n) == 2) then           ! found ocean outlet 
             nupstrm(n) = nupstrm(n) + 1    ! one more land cell for n
             idxocn(nr) = n                 ! set ocean outlet or nr to n
          elseif (abs(gmask(n)) == 1) then  ! no ocean outlet, warn user, ignore cell
             write(iulog,*) 'rtmini ERROR no downstream ocean cell ', &
               g,nr,gmask(nr),dwnstrm_index(nr), &
               n,gmask(n),dwnstrm_index(n)
             call shr_sys_abort('rtmini ERROR no downstream ocean cell')
          else 
             write(iulog,*) 'rtmini ERROR downstream cell is non-ocean,non-land', &
               g,nr,gmask(nr),dwnstrm_index(nr), &
               n,gmask(n),dwnstrm_index(n)
             call shr_sys_abort('rtmini ERROR downstream cell non ocean land')
          endif
       elseif (gmask(n) == 2) then  ! ocean, give to self
          nupstrm(n) = nupstrm(n) + 1
          idxocn(nr) = n
       endif
    enddo
    call t_stopf('mosarti_dec_basins')

    ! check

    nbas_chk = 0
    nrof_chk = 0
    do nr=1,rtmlon*rtmlat
!      !if (masterproc) write(iulog,*) 'nupstrm check ',nr,gmask(nr),nupstrm(nr),idxocn(nr)
       if (gmask(nr) == 2 .and. nupstrm(nr) > 0) then
          nbas_chk = nbas_chk + 1
          nrof_chk = nrof_chk + nupstrm(nr)
       endif
    enddo

    if (nbas_chk /= nbas .or. nrof_chk /= nrof) then
       write(iulog,*) 'rtmini ERROR nbas nrof check',nbas,nbas_chk,nrof,nrof_chk
       call shr_sys_abort('rtmini ERROR nbas nrof check')
    endif

    !-------------------------------------------------------
    !--- Now allocate those basins to pes
    !-------------------------------------------------------

    call t_startf('mosarti_dec_distr')

    !--- this is the heart of the decomp, need to set pocn and nop by the end of this
    !--- pocn is the pe that gets the basin associated with ocean outlet nr
    !--- nop is a running count of the number of rtm cells/pe 

    allocate(pocn(rtmlon*rtmlat),     &  !global rtm array
             nop(0:npes-1), &
             nba(0:npes-1))

    pocn = -99
    nop = 0
    nba = 0

    if (trim(decomp_option) == 'basin') then
       baspe = 0
       maxrtm = int(float(nrof)/float(npes)*0.445) + 1
       nloops = 3
       minbas = nrof
       do nl=1,nloops
          maxbas = minbas - 1
          minbas = maxval(nupstrm)/(2**nl)
          if (nl == nloops) minbas = min(minbas,1)
          do nr=1,rtmlon*rtmlat
             if (gmask(nr) == 2 .and. nupstrm(nr) > 0 .and. nupstrm(nr) >= minbas .and. nupstrm(nr) <= maxbas) then
                ! Decomp options
                !   find min pe (implemented but scales poorly)
                !   use increasing thresholds (implemented, ok load balance for l2r or calc)
                !   distribute basins using above methods but work from max to min basin size
                !
                !--------------
                ! find min pe
                !             baspe = 0
                !             do n = 1,npes-1
                !                if (nop(n) < nop(baspe)) baspe = n
                !             enddo
                !--------------
                ! find next pe below maxrtm threshhold and increment
                do while (nop(baspe) > maxrtm)
                   baspe = baspe + 1
                   if (baspe > npes-1) then
                      baspe = 0
                      maxrtm = max(maxrtm*1.5, maxrtm+1.0)   ! 3 loop, .445 and 1.5 chosen carefully
                   endif
                enddo
                !--------------
                if (baspe > npes-1 .or. baspe < 0) then
                   write(iulog,*) 'ERROR in decomp for MOSART ',nr,npes,baspe
                   call shr_sys_abort('ERROR rtm decomp')
                endif
                nop(baspe) = nop(baspe) + nupstrm(nr)
                nba(baspe) = nba(baspe) + 1
                pocn(nr) = baspe
             endif
          enddo ! nr
       enddo ! nl

       ! set pocn for land cells, was set for ocean above
       do nr=1,rtmlon*rtmlat
          if (idxocn(nr) > 0) then
             pocn(nr) = pocn(idxocn(nr))
             if (pocn(nr) < 0 .or. pocn(nr) > npes-1) then
                write(iulog,*) 'Rtmini ERROR pocn lnd setting ',&
                   nr,idxocn(nr),idxocn(idxocn(nr)),pocn(idxocn(nr)),pocn(nr),npes
                call shr_sys_abort('rtmini ERROR pocn lnd')
             endif
          endif
       enddo

    elseif (trim(decomp_option) == '1d') then
       ! distribute active points in 1d fashion to pes
       ! baspe is the pe assignment
       ! maxrtm is the maximum number of points to assign to each pe
       baspe = 0
       maxrtm = (nrof-1)/npes + 1
       do nr=1,rtmlon*rtmlat
          if (gmask(nr) == 1 .or. gmask(nr) == 2) then
             pocn(nr) = baspe
             nop(baspe) = nop(baspe) + 1
             if (nop(baspe) >= maxrtm) then
                baspe = (mod(baspe+1,npes))
                if (baspe < 0 .or. baspe > npes-1) then
                   write(iulog,*) 'Rtmini ERROR basepe ',baspe,npes
                   call shr_sys_abort('rtmini ERROR pocn lnd')
                endif
             endif
          endif
       enddo

    elseif (trim(decomp_option) == 'roundrobin') then
       ! distribute active points in roundrobin fashion to pes
       ! baspe is the pe assignment
       ! maxrtm is the maximum number of points to assign to each pe
       baspe = 0
       do nr=1,rtmlon*rtmlat
          if (gmask(nr) == 1 .or. gmask(nr) == 2) then
             pocn(nr) = baspe
             nop(baspe) = nop(baspe) + 1
             baspe = (mod(baspe+1,npes))
             if (baspe < 0 .or. baspe > npes-1) then
                write(iulog,*) 'Rtmini ERROR basepe ',baspe,npes
                call shr_sys_abort('rtmini ERROR pocn lnd')
             endif
          endif
       enddo

    else
       write(iulog,*) 'Rtmini ERROR decomp option unknown ',trim(decomp_option)
       call shr_sys_abort('rtmini ERROR pocn lnd')
    endif  ! decomp_option

    if (masterproc) then
       write(iulog,*) 'MOSART decomp option           = ',trim(decomp_option)
       write(iulog,*) 'MOSART cells and basins total  = ',nrof,nbas
       write(iulog,*) 'MOSART cells per basin avg/max = ',nrof/nbas,maxval(nupstrm)
       write(iulog,*) 'MOSART cells per pe    min/max = ',minval(nop),maxval(nop)
       write(iulog,*) 'MOSART basins per pe   min/max = ',minval(nba),maxval(nba)
    endif

    deallocate(idxocn,nupstrm)

    !-------------------------------------------------------
    !--- Count and distribute cells to rglo2gdc
    !-------------------------------------------------------

    rtmCTL%numr   = 0
    rtmCTL%lnumr  = 0

    do n = 0,npes-1
       if (iam == n) then
          rtmCTL%begr  = rtmCTL%numr  + 1
       endif
       rtmCTL%numr  = rtmCTL%numr  + nop(n)
       if (iam == n) then
          rtmCTL%lnumr = rtmCTL%lnumr + nop(n)
          rtmCTL%endr  = rtmCTL%begr  + rtmCTL%lnumr  - 1
       endif
    enddo

    allocate(rglo2gdc(rtmlon*rtmlat), &  !global rtm array
             nrs(0:npes-1))
    nrs = 0
    rglo2gdc = 0

    ! nrs is begr on each pe
    nrs(0) = 1
    do n = 1,npes-1
       nrs(n) = nrs(n-1) + nop(n-1)
    enddo

    ! reuse nba for nop-like counter here
    ! pocn -99 is unused cell
    nba = 0
    do nr = 1,rtmlon*rtmlat
       if (pocn(nr) >= 0) then
          rglo2gdc(nr) = nrs(pocn(nr)) + nba(pocn(nr))
          nba(pocn(nr)) = nba(pocn(nr)) + 1          
       endif
    enddo
    do n = 0,npes-1
       if (nba(n) /= nop(n)) then
          write(iulog,*) 'Rtmini ERROR rtm cell count ',n,nba(n),nop(n)
          call shr_sys_abort('Rtminit ERROR rtm cell count')
       endif
    enddo

    deallocate(nop,nba,nrs)
    deallocate(pocn)
    call t_stopf('mosarti_dec_distr')

    !-------------------------------------------------------
    !--- adjust area estimation from DRT algorithm for those outlet grids
    !--- useful for grid-based representation only
    !-------------------------------------------------------

    do n=1,rtmlon*rtmlat
       nr = rglo2gdc(n)
!       write(iulog,*) 'tcx area1 ',n,nr,TUnit%area(n)
       if (TUnit%area(n) <= 0._r8) then
          i = mod(n-1,rtmlon) + 1
          j = (n-1)/rtmlon + 1
          dx = (rlone(i) - rlonw(i)) * deg2rad
          dy = sin(rlatn(j)*deg2rad) - sin(rlats(j)*deg2rad)
          TUnit%area(n) = abs(1.e6_r8 * dx*dy*re*re)
          if (masterproc .and. TUnit%area(n) <= 0) then
             write(iulog,*) 'Warning! Zero area for unit ', n, TUnit%area(n),dx,dy,re
          end if
!          write(iulog,*) 'tcx area2 ',n,nr,TUnit%area(n),i,j,dx,dy
       end if
       if (TUnit%rlen(n) <= 0._r8) then
          nn = dwnstrm_index(n)
          if (nn > 0) then
             g = rglo2gdc(nn)
          else
             g = -99
          end if

          if (g <= 0) then
             TUnit%rlen(n) = 0._r8
          elseif (g < rtmCTL%begr .or. g > rtmCTL%endr) then
             write(iulog,*) 'Rtmini: error in ddist calc ',nr,g,rtmCTL%begr,rtmCTL%endr
             call shr_sys_abort('Rtmini: error in ddist calc')
          else
             dy = deg2rad * abs(rtmCTL%latc(nr)-rtmCTL%latc(g)) * re*1000._r8
             dx = rtmCTL%lonc(nr)-rtmCTL%lonc(g)
             dx1 = abs(dx)
             dx2 = abs(dx+360._r8)
             dx3 = abs(dx-360._r8)
             dx = min(dx1,dx2,dx3)
             dx = deg2rad * dx * re*1000._r8 * &
                  0.5_r8*(cos(rtmCTL%latc(nr)*deg2rad)+ &
                          cos(rtmCTL%latc(g)*deg2rad))
             TUnit%rlen(n) = sqrt(dx*dx + dy*dy)
          endif
       end if
    end do

    call t_stopf('mosarti_decomp')

    !-------------------------------------------------------
    !--- Write per-processor runoff bounds depending on dbug level
    !-------------------------------------------------------

    call t_startf('mosarti_print')

    call shr_sys_flush(iulog)
    if (masterproc) then
       write(iulog,*) 'total runoff cells numr  = ',rtmCTL%numr
    endif
    call shr_sys_flush(iulog)
    call mpi_barrier(mpicom_rof,ier)
    npmin = 0
    npmax = npes-1
    npint = 1
    if (dbug == 0) then
       npmax = 0
    elseif (dbug == 1) then
       npmax = min(npes-1,4)
    elseif (dbug == 2) then
       npint = npes/8
    elseif (dbug == 3) then
       npint = 1
    endif
    do np = npmin,npmax,npint
       pid = np
       if (dbug == 1) then
          if (np == 2) pid=npes/2-1
          if (np == 3) pid=npes-2
          if (np == 4) pid=npes-1
       endif
       pid = max(pid,0)
       pid = min(pid,npes-1)
       if (iam == pid) then
          write(iulog,'(2a,i9,a,i9,a,i9,a,i9)') &
             'MOSART decomp info',' proc = ',iam, &
             ' begr = ',rtmCTL%begr,&
             ' endr = ',rtmCTL%endr, &
             ' numr = ',rtmCTL%lnumr
       endif
       call shr_sys_flush(iulog)
       call mpi_barrier(mpicom_rof,ier)
    enddo

    call t_stopf('mosarti_print')

    !-------------------------------------------------------
    ! Allocate local flux variables
    !-------------------------------------------------------

    call t_startf('mosarti_vars')

    allocate (fluxout (rtmCTL%begr:rtmCTL%endr,nt_rtm), &
              ddist   (rtmCTL%begr:rtmCTL%endr),        &
              evel    (rtmCTL%begr:rtmCTL%endr,nt_rtm), &
              sfluxin (rtmCTL%begr:rtmCTL%endr,nt_rtm), stat=ier)
    if (ier /= 0) then
       write(iulog,*)'Rtmgridini: Allocation ERROR for ',&
            'fluxout, ddist'
       call shr_sys_abort('Rtmgridini: Allocationt ERROR volr')
    end if
    fluxout(:,:) = 0._r8
    ddist(:)     = 0._r8
    sfluxin(:,:) = 0._r8

    !-------------------------------------------------------
    ! Allocate runoff datatype 
    !-------------------------------------------------------

    call RunoffInit(rtmCTL%begr, rtmCTL%endr, rtmCTL%numr)

    !-------------------------------------------------------
    ! Initialize rtm flood - rtmCTL%fthresh and evel
    !-------------------------------------------------------

    if (do_rtmflood) then
       write(iulog,*)'Rtmgridini: Flood not validated in this version, abort'
       call shr_sys_abort('Rtmgridini: Flood feature unavailable')
       call RtmFloodInit (frivinp_rtm, rtmCTL%begr, rtmCTL%endr, rtmCTL%fthresh, evel)
    else
       effvel(:) = effvel0  ! downstream velocity (m/s)
       rtmCTL%fthresh(:) = abs(spval)
       do nt = 1,nt_rtm
          do nr = rtmCTL%begr,rtmCTL%endr
             evel(nr,nt) = effvel(nt)
          enddo
       enddo
    end if

    !-------------------------------------------------------
    ! Initialize runoff data type
    !-------------------------------------------------------

    allocate(rgdc2glo(rtmCTL%numr), stat=ier)
    if (ier /= 0) then
       write(iulog,*)'Rtmini ERROR allocation of rtmCTL%gdc2glo'
       call shr_sys_abort('Rtmini ERROR allocate of gdc2glo')
    end if

    ! Set map from local to global index space
    numr = 0
    do j = 1,rtmlat
    do i = 1,rtmlon
       n = (j-1)*rtmlon + i
       nr = rglo2gdc(n)
       if (nr > 0) then
          numr = numr + 1
          rgdc2glo(nr) = n         
          rtmCTL%mask(nr) = gmask(n)
       endif
    end do
    end do
    if (numr /= rtmCTL%numr) then
       write(iulog,*) 'Rtmini ERROR numr and rtmCTL%numr are different ',numr,rtmCTL%numr
       call shr_sys_abort('Rtmini ERROR numr')
    endif
    deallocate(gmask)

    ! Determine runoff datatype variables
    lrtmarea = 0.0_r8
    cnt = 0
    do nr = rtmCTL%begr,rtmCTL%endr
       rtmCTL%gindex(nr) = rgdc2glo(nr)
       n = rgdc2glo(nr)
       i = mod(n-1,rtmlon) + 1
       j = (n-1)/rtmlon + 1
       if (n <= 0 .or. n > rtmlon*rtmlat) then
          write(iulog,*) 'Rtmini ERROR gdc2glo, nr,ng= ',nr,n
          call shr_sys_abort('Rtmini ERROR gdc2glo values')
       endif
       rtmCTL%lonc(nr) = rtmCTL%rlon(i)
       rtmCTL%latc(nr) = rtmCTL%rlat(j)

       if (rtmCTL%mask(nr) == 1) then
          do nt = 1,nt_rtm
             rtmCTL%runofflnd(nr,nt) = rtmCTL%runoff(nr,nt)
             rtmCTL%dvolrdtlnd(nr,nt)= rtmCTL%dvolrdt(nr,nt)
             rtmCTL%volrlnd(nr,nt)= rtmCTL%volr(nr,nt)
          enddo
       elseif (rtmCTL%mask(nr) == 2 .or. rtmCTL%mask(nr) == 3) then
          do nt = 1,nt_rtm
             rtmCTL%runoffocn(nr,nt) = rtmCTL%runoff(nr,nt)
             rtmCTL%dvolrdtocn(nr,nt)= rtmCTL%dvolrdt(nr,nt)
          enddo
       endif

       rtmCTL%area(nr) = TUnit%area(n)
       ddist(nr)       = TUnit%rlen(n)
       lrtmarea = lrtmarea + rtmCTL%area(nr)
       if (dwnstrm_index(n) <= 0) then
          rtmCTL%dsig(nr) = 0
          rtmCTL%dsil(nr) = 0
       else
          if (rglo2gdc(dwnstrm_index(n)) == 0) then
             write(iulog,*) 'Rtmini ERROR glo2gdc dwnstrm ',&
                  nr,n,dwnstrm_index(n),rglo2gdc(dwnstrm_index(n))
             call shr_sys_abort('Rtmini ERROT glo2gdc dwnstrm')
          endif
          cnt = cnt + 1
          rtmCTL%dsig(nr) = dwnstrm_index(n)
          rtmCTL%dsil(nr) = rglo2gdc(dwnstrm_index(n))
       endif

    enddo
    deallocate(dwnstrm_index)
    deallocate(rglo2gdc)
    deallocate(rgdc2glo)
    call shr_mpi_sum(lrtmarea,rtmCTL%totarea,mpicom_rof,'rtm totarea',all=.true.)
    if (masterproc) write(iulog,*) 'Rtmini  earth area ',4.0_r8*shr_const_pi*1.0e6_r8*re*re
    if (masterproc) write(iulog,*) 'Rtmini MOSART area ',rtmCTL%totarea

    !-------------------------------------------------------
    ! Compute Sparse Matrix
    !-------------------------------------------------------

    lsize = rtmCTL%lnumr
    gsize = rtmlon*rtmlat
    allocate(gindex(lsize))
    do nr = rtmCTL%begr,rtmCTL%endr
       gindex(nr-rtmCTL%begr+1) = rtmCTL%gindex(nr)
    enddo
    call mct_gsMap_init( gsMap_r, gindex, mpicom_rof, ROFID, lsize, gsize )
    deallocate(gindex)

    ! mct_sMat_init must be given the number of rows and columns that
    ! would be in the full matrix.  Nrows= size of output vector=nb.
    ! Ncols = size of input vector = na.
    call mct_sMat_init(sMat, gsize, gsize, cnt)
    igrow = mct_sMat_indexIA(sMat,'grow')
    igcol = mct_sMat_indexIA(sMat,'gcol')
    iwgt  = mct_sMat_indexRA(sMat,'weight')
    cnt = 0
    do nr = rtmCTL%begr,rtmCTL%endr
       if (rtmCTL%dsig(nr) > 0) then
          cnt = cnt + 1
          sMat%data%rAttr(iwgt ,cnt) = 1.0
          sMat%data%iAttr(igrow,cnt) = rtmCTL%dsig(nr)
          sMat%data%iAttr(igcol,cnt) = rtmCTL%gindex(nr)
       endif
    enddo

    call mct_sMatP_Init(sMatP, sMat, gsMap_r, gsMap_r, 0, mpicom_rof, ROFID)
    lsize = mct_smat_gNumEl(sMatP%Matrix,mpicom_rof)
    if (masterproc) write(iulog,*) "Rtmini Done initializing SmatP, nElements = ",lsize

    ! keep only sMatP
    call mct_sMat_clean(sMat)
    call mct_gsmap_clean(gsmap_r)

    !-------------------------------------------------------
    ! Compute timestep and subcycling number
    !-------------------------------------------------------

    dtover = 0._r8
    dtovermax = 0._r8
!    write(iulog,*) "tcx ddist ",minval(ddist),maxval(ddist)
!    write(iulog,*) "tcx evel  ",minval(evel),maxval(evel)
    do nt=1,nt_rtm
       do nr=rtmCTL%begr,rtmCTL%endr
          if (ddist(nr) /= 0._r8) then
             dtover = evel(nr,nt)/ddist(nr)
          else
             dtover = 0._r8
          endif
          dtovermax = max(dtovermax,dtover)
       enddo
    enddo
    dtover = dtovermax
    call mpi_allreduce(dtover,dtovermax,1,MPI_REAL8,MPI_MAX,mpicom_rof,ier)

!    if (dtovermax > 0._r8) then
!       delt_rtm_max = (1.0_r8/dtovermax)*cfl_scale
!    else
!       write(iulog,*) 'rtmini ERROR in delt_rtm_max ',delt_rtm_max,dtover
!       call shr_sys_abort('rtmini ERROR delt_rtm_max')
!    endif

    delt_rtm_max = 600._r8  ! here set the time interval for routing as 10 mins, which is sufficient for 1/8th degree resolution and coarser.

    if (masterproc) write(iulog,*) 'rtm max timestep = ',delt_rtm_max,' (sec) for cfl_scale = ',cfl_scale
    if (masterproc) call shr_sys_flush(iulog)

    call t_stopf('mosarti_vars')

    !-------------------------------------------------------
    ! Initialize mosart
    !-------------------------------------------------------

    call t_startf('mosarti_mosart_init')

    deallocate (TUnit%fdir,TUnit%ID0,TUnit%dnID,TUnit%rlen, TUnit%area)
    !=== initialize MOSART related variables
!    if (masterproc) write(iulog,*) ' call mosart_init'
!    if (masterproc) call shr_sys_flush(iulog)
    call MOSART_init()

    call t_stopf('mosarti_mosart_init')

    !-------------------------------------------------------
    ! Read restart/initial info
    !-------------------------------------------------------

    call t_startf('mosarti_restart')

!    if (masterproc) write(iulog,*) ' call RtmRestFileRead'
!    if (masterproc) call shr_sys_flush(iulog)

    ! The call below opens and closes the file
    if ((nsrest == nsrStartup .and. finidat_rtm /= ' ') .or. &
        (nsrest == nsrContinue) .or. & 
        (nsrest == nsrBranch  )) then
        call RtmRestFileRead( file=fnamer )
        fluxout(:,:) = rtmCTL%fluxout(:,:)
        !write(iulog,*) ' MOSART init file is read'
        TRunoff%wh   = rtmCTL%wh
        TRunoff%wt   = rtmCTL%wt
        TRunoff%wr   = rtmCTL%wr
        TRunoff%erout= rtmCTL%erout
        do nr = rtmCTL%begr,rtmCTL%endr
            call UpdateState_hillslope(nr)
            call UpdateState_subnetwork(nr)
            call UpdateState_mainchannel(nr)
        enddo
    end if

    call t_stopf('mosarti_restart')

    !-------------------------------------------------------
    ! Initialize rtm history handler and fields
    !-------------------------------------------------------

    call t_startf('mosarti_histinit')

!    if (masterproc) write(iulog,*) ' call RtmHistFldsInit'
!    if (masterproc) call shr_sys_flush(iulog)

    call RtmHistFldsInit()
    if (nsrest==nsrStartup .or. nsrest==nsrBranch) then
       call RtmHistHtapesBuild()
    end if
    call RtmHistFldsSet()

    if (masterproc) write(iulog,*) ' rtmini done'
    if (masterproc) call shr_sys_flush(iulog)

    call t_stopf('mosarti_histinit')

  end subroutine Rtmini

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: Rtmrun
!
! !INTERFACE:
  subroutine Rtmrun(totrunin,surrunin, subrunin, gwlrunin, rstwr, nlend, rdate)
!
! !DESCRIPTION:
! River routing model
! Input is subrunin, totrunin
! Input/output is fluxout, volr.
! Outputs are dvolrdt\_r, dvolrdt\_lnd\_r, dvolrdt\_ocn\_r, flxocn\_r, flxlnd\_r.
!
! !USES:
!
! !ARGUMENTS:
    implicit none
    real(r8),         pointer    :: totrunin(:,:)  ! cell tracer lnd forcing on rtm grid (mm/s)
    real(r8),         pointer    :: surrunin(:,:)  ! cell tracer lnd forcing on rtm grid (mm/s)
    real(r8),         pointer    :: subrunin(:,:)  ! cell tracer lnd forcing on rtm grid (mm/s)
    real(r8),         pointer    :: gwlrunin(:,:)  ! cell tracer lnd forcing on rtm grid (mm/s)
    logical ,         intent(in) :: rstwr          ! true => write restart file this step)
    logical ,         intent(in) :: nlend          ! true => end of run on this step
    character(len=*), intent(in) :: rdate          ! restart file time stamp for name
!
! !CALLED FROM:
! subroutine RtmMap in this module
!
! !REVISION HISTORY:
! Author: Sam Levis
!
!
! !LOCAL VARIABLES:
!EOP
    integer  :: i, j, n, nr, ns, nt, n2, nf ! indices
    real(r8) :: dvolrdt                     ! change in storage in discharge units (m3/s)
    real(r8) :: sumfin(nt_rtm),sumfex(nt_rtm)
    real(r8) :: sumrin(nt_rtm),sumdvt(nt_rtm)
    real(r8) :: diag2(10,nt_rtm)            ! diagnostics in m3/s
    real(r8) :: diag2_global(10,nt_rtm)     ! global budget sum
    real(r8) :: diag_global(nt_rtm)         ! global budget sum
    real(r8) :: budget1(nt_rtm)             ! budget check in m3/s
    logical  :: budget_check                ! do global budget check
    logical  :: runoff_check                ! diagnose runoff data
    real(r8),parameter :: budget_tolerance = 1.0e-6   ! budget tolerance, m3/day
    logical  :: abort                       ! abort flag
    real(r8) :: sum1,sum2
    integer  :: yr, mon, day, ymd, tod      ! time information
    integer  :: nsub                        ! subcyling for cfl
    real(r8) :: delt                        ! delt associated with subcycling
    real(r8) :: delt_rtm                    ! real value of rtm_tstep
    integer , save :: nsub_save             ! previous nsub
    real(r8), save :: delt_save             ! previous delt
    logical , save :: first_time = .true.   ! first time flag (for backwards compatibility)
    character(len=256) :: filer             ! restart file name
    integer  :: cnt                         ! counter for gridcells
    character(len=16384) :: rList           ! list of fields for SM multiply
    integer,parameter  :: dbug = 1          ! local debug flag
    character(*),parameter :: subname = '(Rtmrun) '
!-----------------------------------------------------------------------

    call t_startf('mosartr_tot')
    call shr_sys_flush(iulog)

    call get_curr_date(yr, mon, day, tod)
    ymd = yr*10000 + mon*100 + day
    if (tod == 0 .and. masterproc) then
       write(iulog,*) ' '
       write(iulog,'(2a,i10,i6)') trim(subname),' model date is',ymd,tod
    endif

    delt_rtm = rtm_tstep*1.0_r8
    if (first_time) then
       if (masterproc) write(iulog,'(2a,g20.12)') trim(subname),': MOSART coupling period ',delt_rtm
    end if

    budget_check = .false.
    runoff_check = .false.
    if (day == 1 .and. mon == 1) budget_check = .true.
    if (tod == 0) runoff_check = .true.

    do n = rtmCTL%begr,rtmCTL%endr
    do nt = 1,nt_rtm
       !n2 = n-rtmCTL%begr+1
       !-- surface is (total - subsurface)
       !!!TRunoff%qsur(n,nt) = totrunin(n,nt) - subrunin(n,nt)
       !!!TRunoff%qsub(n,nt) = subrunin(n,nt)
       TRunoff%qsur(n,nt) = surrunin(n,nt)
       TRunoff%qsub(n,nt) = subrunin(n,nt)
       TRunoff%qgwl(n,nt) = gwlrunin(n,nt)

    enddo
    enddo

    ! now correct negative runoff values for tracer 1 (liquid water)
    ! this needs to be reviewed 
!    do n = rtmCTL%begr,rtmCTL%endr
!       if (totrunin(n,1) <= 0._r8) then
!          TRunoff%qsur(n,1) = 0._r8
!          TRunoff%qsub(n,1) = 0._r8
!       elseif (totrunin(n,1) > 0._r8 .and. totrunin(n,1) <= subrunin(n,1)) then
!          TRunoff%qsur(n,1) = 0._r8
!          TRunoff%qsub(n,1) = totrunin(n,1)
!       else
!          TRunoff%qsur(n,1) = totrunin(n,1) - subrunin(n,1)
!          TRunoff%qsub(n,1) = subrunin(n,1)
!       endif
!    enddo

    ! convert from kg/m2-s (mm/s) to m/s
    do n = rtmCTL%begr,rtmCTL%endr
    do nt = 1,nt_rtm
       TRunoff%qsur(n,nt) = TRunoff%qsur(n,nt) * 0.001_r8
       TRunoff%qsub(n,nt) = TRunoff%qsub(n,nt) * 0.001_r8
       TRunoff%qgwl(n,nt) = TRunoff%qgwl(n,nt) * 0.001_r8
    enddo
    enddo

!    write(iulog,*) 'tcx trunoff check1r ',minval(TRunoff%qsur(:,1)),maxval(TRunoff%qsur(:,1))
!    write(iulog,*) 'tcx trunoff check2r ',minval(TRunoff%qsur(:,2)),maxval(TRunoff%qsur(:,2))
!    write(iulog,*) 'tcx trunoff check1b ',minval(TRunoff%qsub(:,1)),maxval(TRunoff%qsub(:,1))
!    write(iulog,*) 'tcx trunoff check2b ',minval(TRunoff%qsub(:,2)),maxval(TRunoff%qsub(:,2))
!    call shr_sys_flush(iulog)

    ! BUDGET per water tracer, in m3/s = totrunin + (volr_i - volr_f)/dt - flood - runoff ~ 0.0
    ! BUDGET, totrunin input, add initial volume, final volume removed later
    if (budget_check) then
       call t_startf('mosartr_budget')
       budget1 = 0.0_r8
       do nt = 1,nt_rtm
       do nr = rtmCTL%begr,rtmCTL%endr
          budget1(nt) = budget1(nt) + totrunin(nr,nt)*rtmCTL%area(nr) &
                                    + rtmCTL%volr(nr,nt)/delt_rtm
       enddo
       enddo
!       write(iulog,*) 'tcx b1 ',minval(budget1),maxval(budget1)
!       write(iulog,*) 'tcx b1a',minval(rtmCTL%volr),maxval(rtmCTL%volr),delt_rtm
!       write(iulog,*) 'tcx b1b',minval(totrunin),maxval(totrunin)
!       write(iulog,*) 'tcx b1c',minval(subrunin),maxval(subrunin)
!       write(iulog,*) 'tcx b1d',minval(rtmCTL%area),maxval(rtmCTL%area)
       call t_stopf('mosartr_budget')
    endif

    ! Remove water from rtm and send back to clm
    ! Just consider land points and only remove liquid water 
    ! rtmCTL%flood needs to be a flux - in units of mm/s
    ! totrunin and subrunin is a flux (mm/s)

    call t_startf('mosartr_flood')
    nt = 1 
    do nr = rtmCTL%begr,rtmCTL%endr
       ! initialize rtmCTL%flood to zero
       rtmCTL%flood(nr) = 0._r8
       if (rtmCTL%mask(nr) == 1) then
          if (rtmCTL%volr(nr,nt) > rtmCTL%fthresh(nr)) then 
             ! determine flux that is sent back to the land
             ! need to convert to mm/s to be consistent with totrunin units
             rtmCTL%flood(nr) = &
                  1000._r8*(rtmCTL%volr(nr,nt)-rtmCTL%fthresh(nr)) / &
                  (delt_rtm*rtmCTL%area(nr))

             ! rtmCTL%flood will be sent back to land - so must subtract this 
             ! from the input runoff from land
             ! tcraig, comment - this seems like an odd approach, you
             !   might create negative forcing.  why not take it out of
             !   the volr directly?  it's also odd to compute this
             !   at the initial time of the time loop.  why not do
             !   it at the end or even during the run loop as the
             !   new volume is computed.  fluxout depends on volr, so
             !   how this is implemented does impact the solution.
             surrunin(nr,nt)= surrunin(nr,nt) - rtmCTL%flood(nr)
          endif
       endif
    enddo
    call t_stopf('mosartr_flood')
    
    ! BUDGET, flood out, just liquid water term
    if (budget_check) then
       call t_startf('mosartr_budget')
       nt = 1
       do nr = rtmCTL%begr,rtmCTL%endr
          budget1(nt) = budget1(nt) - rtmCTL%flood(nr)*rtmCTL%area(nr)
       enddo
!       write(iulog,*) 'tcx b2 ',minval(budget1),maxval(budget1)
!       write(iulog,*) 'tcx b2a',minval(rtmCTL%flood),maxval(rtmCTL%flood)
       call t_stopf('mosartr_budget')
    endif

    ! Subcycling

    call t_startf('mosartr_subcycling')

    nsub = int(delt_rtm/delt_rtm_max)
    if (float(nsub)*delt_rtm_max < delt_rtm) then
       nsub = int(delt_rtm/delt_rtm_max) + 1
    end if
    delt = delt_rtm/float(nsub)
    if (delt /= delt_save) then
       if (masterproc) then
          write(iulog,'(2a,2g20.12,2i12)') trim(subname),': MOSART delt update from/to',delt_save,delt,nsub_save,nsub
       end if
    endif

    nsub_save = nsub
    delt_save = delt

    sumfin = 0._r8
    sumfex = 0._r8
    sumrin = 0._r8
    sumdvt = 0._r8
    rtmCTL%runoff = 0._r8
    rtmCTL%runoffall = 0._r8
    rtmCTL%runofflnd = spval
    rtmCTL%runoffocn = spval
    rtmCTL%dvolrdt = 0._r8
    rtmCTL%dvolrdtlnd = spval
    rtmCTL%dvolrdtocn = spval

    Tctl%DeltaT = delt

    do ns = 1,nsub

       call t_startf('mosartr_euler')
       call Euler()
       call t_stopf('mosartr_euler')

       call t_startf('mosartr_SMmult')
       sfluxin = 0._r8
#ifdef NO_MCT
       do n = rtmCTL%begr,rtmCTL%endr
          nr = rtmCTL%dsil(n)
          if (abs(rtmCTL%mask(n)) == 1) then
             if (nr < rtmCTL%begr .or. nr > rtmCTL%endr) then
                write(iulog,*) trim(subname),':MOSART ERROR: non-local communication ',n,nr
                call shr_sys_abort(trim(subname)//' ERROR non local comm')
             endif
             do nt = 1,nt_rtm
                sfluxin(nr,nt) = sfluxin(nr,nt) + fluxout(n,nt)
             enddo
          endif
       enddo
#else
       if (ns == 1 .and. first_time) then
          write(rList,'(a,i3.3)') 'tr',1
          do nt = 2,nt_rtm
             write(rList,'(a,i3.3)') trim(rList)//':tr',nt
          enddo
          write(iulog,'(2a)') trim(subname),':MOSART initialize avect ',trim(rList)
          call mct_aVect_init(avsrc,rList=rList,lsize=rtmCTL%lnumr)
          call mct_aVect_init(avdst,rList=rList,lsize=rtmCTL%lnumr)
       endif

       !--- copy fluxout into avsrc ---
       cnt = 0
       do n = rtmCTL%begr,rtmCTL%endr
          cnt = cnt + 1
          do nt = 1,nt_rtm
             avsrc%rAttr(nt,cnt) = fluxout(n,nt)
          enddo
       enddo
       call mct_avect_zero(avdst)

       call mct_sMat_avMult(avsrc, sMatP, avdst)

       !--- add mapped fluxout to sfluxin ---
       cnt = 0
       do n = rtmCTL%begr,rtmCTL%endr
          cnt = cnt + 1
          do nt = 1,nt_rtm
             sfluxin(n,nt) = sfluxin(n,nt) + avdst%rAttr(nt,cnt)
          enddo
       enddo
#endif
       call t_stopf('mosartr_SMmult')

       if (dbug > 1) then
          do nt = 1,nt_rtm
             sum1 = 0._r8
             sum2 = 0._r8
             do n = rtmCTL%begr,rtmCTL%endr
                sum1 = sum1 + sfluxin(n,nt)
                sum2 = sum2 + fluxout(n,nt)
             enddo
             if (abs(sum1+sum2) > 0.0_r8) then
             if (abs(sum1-sum2)/(sum1+sum2) > 1.0e-12) then
                write(iulog,*) trim(subname),':MOSART Warning: fluxin = ',sum1,&
                     ' not equal to fluxout = ',sum2,' for tracer ',nt
             endif
             endif
          enddo
       endif

       do nt = 1,nt_rtm
       do n = rtmCTL%begr,rtmCTL%endr
          dvolrdt = sfluxin(n,nt) + totrunin(n,nt)*rtmCTL%area(n) - fluxout(n,nt)

          if (dbug > 1) then
             sumfin(nt) = sumfin(nt) + sfluxin(n,nt)
             sumfex(nt) = sumfex(nt) + fluxout(n,nt)
             sumrin(nt) = sumrin(nt) + totrunin(n,nt)*rtmCTL%area(n)
             sumdvt(nt) = sumdvt(nt) + dvolrdt
          endif

          if (abs(rtmCTL%mask(n)) == 1) then         ! land points
             rtmCTL%volr(n,nt) = rtmCTL%volr(n,nt) + dvolrdt*delt
             fluxout(n,nt)  = TRunoff%flow(n,nt)
          else
             rtmCTL%volr(n,nt) = 0._r8
             fluxout(n,nt) = 0._r8
          endif

          if (abs(rtmCTL%mask(n)) == 1) then
             rtmCTL%runoff(n,nt) = rtmCTL%runoff(n,nt) + fluxout(n,nt)
             rtmCTL%runoffall(n,nt) = rtmCTL%runoffall(n,nt) + TRunoff%flow(n,nt)
          elseif (rtmCTL%mask(n) == 2) then
             rtmCTL%runoff(n,nt) = rtmCTL%runoff(n,nt) + dvolrdt
             rtmCTL%runoffall(n,nt) = rtmCTL%runoffall(n,nt) + TRunoff%flow(n,nt)
          elseif (dvolrdt /= 0.0_r8) then
             ! this water has no where to go.....
             write(iulog,*) subname,' runoff dvolrdt ERROR ',nt,n,rtmCTL%mask(n),dvolrdt
             call shr_sys_abort(subname//' runoff dvolrdt ERROR')
          endif

          ! Convert local dvolrdt (in m3/s) to output dvolrdt (in mm/s)
          if (rtmCTL%area(n) <= 1.e-10) then !
             write(iulog,*) 'area error: ', n, rtmCTL%area(n)
             call shr_sys_flush(iulog)
          else
             rtmCTL%dvolrdt(n,nt) = rtmCTL%dvolrdt(n,nt) + 1000._r8*dvolrdt/rtmCTL%area(n)
          endif

       enddo
       enddo

    enddo

    ! average fluxes over subcycling
    rtmCTL%runoff  = rtmCTL%runoff / float(nsub)
    rtmCTL%runoffall  = rtmCTL%runoffall / float(nsub)
    rtmCTL%dvolrdt = rtmCTL%dvolrdt / float(nsub)
    rtmCTL%fluxout = fluxout

    do n = rtmCTL%begr,rtmCTL%endr
       if (rtmCTL%mask(n) == 1) then
          do nt = 1,nt_rtm
             rtmCTL%volrlnd(n,nt)= rtmCTL%volr(n,nt)
            ! rtmCTL%runofflnd(n,nt) = rtmCTL%runoff(n,nt)
             rtmCTL%runofflnd(n,nt) = rtmCTL%runoffall(n,nt)
             rtmCTL%dvolrdtlnd(n,nt)= rtmCTL%dvolrdt(n,nt)
          enddo
       elseif (rtmCTL%mask(n) == 2) then
          do nt = 1,nt_rtm
             !rtmCTL%runoffocn(n,nt) = rtmCTL%runoff(n,nt)
             rtmCTL%runoffocn(n,nt) = rtmCTL%runoffall(n,nt)
             rtmCTL%dvolrdtocn(n,nt)= rtmCTL%dvolrdt(n,nt)
          enddo
       endif
    enddo

    ! record states when subsycling completed
    rtmCTL%fluxout = fluxout
    rtmCTL%wh      = TRunoff%wh
    rtmCTL%wt      = TRunoff%wt
    rtmCTL%wr      = TRunoff%wr
    rtmCTL%erout   = TRunoff%erout

    call t_stopf('mosartr_subcycling')

    ! BUDGET, runoff out (only ocean points), subtract final volume out
    if (budget_check) then
       call t_startf('mosartr_budget')
       do nt = 1,nt_rtm
       do nr = rtmCTL%begr,rtmCTL%endr
          if (rtmCTL%mask(nr) == 2) then
             budget1(nt) = budget1(nt) - rtmCTL%runoff(nr,nt)
          endif
          budget1(nt) = budget1(nt) - rtmCTL%volr(nr,nt)/delt_rtm
!          write(iulog,*) 'tcx b3',nt,nr,budget1(nt),rtmCTL%volr(nr,nt)
       enddo
       enddo
!       write(iulog,*) 'tcx b4 ',minval(budget1),maxval(budget1)
!       write(iulog,*) 'tcx b4a',minval(rtmCTL%runoff),maxval(rtmCTL%runoff)
!       write(iulog,*) 'tcx b4b',minval(rtmCTL%volr),maxval(rtmCTL%volr),delt_rtm
       call t_stopf('mosartr_budget')
    endif

    ! RUNOFF check, compute global sums and check
    if (runoff_check) then
       call t_startf('mosartr_rofdiag')
       diag2 = 0.0_r8
       do nt = 1,nt_rtm
       do nr = rtmCTL%begr,rtmCTL%endr
          diag2(1,nt) = diag2(1,nt) + rtmCTL%runoff(nr,nt)
          diag2(2,nt) = diag2(2,nt) + rtmCTL%volr(nr,nt)
          diag2(3,nt) = diag2(3,nt) + rtmCTL%dvolrdt(nr,nt)
       enddo
       enddo
       call shr_mpi_sum(diag2,diag2_global,mpicom_rof,'rtm global budget',all=.false.)
       if (masterproc) then
          write(iulog,'(2a,i10,i6)') trim(subname),' MOSART diagnostics for ',ymd,tod
          do nt = 1,nt_rtm
            write(iulog,'(2a,i4)')        trim(subname),'  tracer = ',nt
            write(iulog,'(2a,i4,g20.12)') trim(subname),'   diag runoff  = ',nt,diag2_global(1,nt)
            write(iulog,'(2a,i4,g20.12)') trim(subname),'   diag volr    = ',nt,diag2_global(2,nt)
            write(iulog,'(2a,i4,g20.12)') trim(subname),'   diag dvolrdt = ',nt,diag2_global(3,nt)
          enddo
       endif
       call t_stopf('mosartr_rofdiag')
    endif

    ! BUDGET, compute global sums and check
    if (budget_check) then
       call t_startf('mosartr_budget')
       call shr_mpi_sum(budget1,diag_global,mpicom_rof,'rtm global budget',all=.false.)
!       write(iulog,*) 'tcx b5 ',minval(budget1),maxval(budget1)
       if (masterproc) then
          write(iulog,*) ' '
          abort = .false.
          do nt = 1,nt_rtm
             diag_global(nt) = diag_global(nt) * 1000._r8 / rtmCTL%totarea * 1.0e6_r8   ! convert from m3/s to kg/m2s*1e6
             write(iulog,'(2a,i10,i6,i4,g20.12)') trim(subname),':BUDGET check (kg/m2s*1e6)= ',ymd,tod,nt,diag_global(nt)
             if (abs(diag_global(nt)) > budget_tolerance) abort = .true.
          enddo
          if (abort) then
             write(iulog,*) trim(subname),':BUDGET abort balance too large ',budget_tolerance
             call shr_sys_abort(trim(subname)//':rtm budget ERROR')
          endif
       endif
       call t_stopf('mosartr_budget')
    endif

    ! Write out RTM history and restart file
    call t_startf('mosartr_hbuf')
    call RtmHistFldsSet()
    call RtmHistUpdateHbuf()
    call t_stopf('mosartr_hbuf')

    call t_startf('mosartr_htapes')
    call RtmHistHtapesWrapup( rstwr, nlend )
    call t_stopf('mosartr_htapes')

    if (rstwr) then
       call t_startf('mosartr_rest')
       filer = RtmRestFileName(rdate=rdate)
       call RtmRestFileWrite( filer, rdate=rdate )
       call t_stopf('mosartr_rest')
    end if

    ! Global water balance calculation and ERROR check
    if (dbug > 1) then
       do nt = 1,nt_rtm
       if (abs(sumdvt(nt)+sumrin(nt)) > 0.0_r8) then
       if (abs((sumdvt(nt)-sumrin(nt))/(sumdvt(nt)+sumrin(nt))) > 1.0e-6) then
          write(iulog,*) trim(subname),':MOSART Warning: water balance nt,dvt,rin,fin,fex = ', &
             nt,sumdvt(nt),sumrin(nt),sumfin(nt),sumfex(nt)
          !call shr_sys_abort()
       endif
       endif
       enddo
    endif

    first_time = .false.

    call shr_sys_flush(iulog)
    call t_stopf('mosartr_tot')

  end subroutine Rtmrun

!-----------------------------------------------------------------------

  subroutine RtmFloodInit(frivinp, begr, endr, fthresh, evel )

    !-----------------------------------------------------------------------
    ! Uses

    ! Input variables
    character(len=*), intent(in) :: frivinp
    integer , intent(in)  :: begr, endr
    real(r8), intent(out) :: fthresh(begr:endr)
    real(r8), intent(out) :: evel(begr:endr,nt_rtm) 

    ! Local variables
    real(r8) , pointer :: rslope(:)   
    real(r8) , pointer :: max_volr(:)
    integer, pointer   :: compdof(:) ! computational degrees of freedom for pio 
    integer :: nt,n,cnt              ! indices
    logical :: readvar               ! read variable in or not
    integer :: ier                   ! status variable
    integer :: dids(2)               ! variable dimension ids 
    type(file_desc_t)  :: ncid       ! pio file desc
    type(var_desc_t)   :: vardesc    ! pio variable desc 
    type(io_desc_t)    :: iodesc     ! pio io desc
    character(len=256) :: locfn      ! local file name

    !Rtm Flood variables for spatially varying celerity
    real(r8) :: effvel(nt_rtm) = 0.7_r8   ! downstream velocity (m/s)
    real(r8) :: min_ev(nt_rtm) = 0.35_r8  ! minimum downstream velocity (m/s)
    real(r8) :: fslope = 1.0_r8           ! maximum slope for which flooding can occur
    character(*),parameter :: subname = '(RtmFloodInit) '
    !-----------------------------------------------------------------------

    allocate(rslope(begr:endr), max_volr(begr:endr), stat=ier)
    if (ier /= 0) call shr_sys_abort(subname // ':: allocation ERROR')

    ! Assume that if SLOPE is on river input dataset so is MAX_VOLR and that
    ! both have the same io descriptor

    call getfil(frivinp, locfn, 0 )
    call ncd_pio_openfile (ncid, trim(locfn), 0)
    call pio_seterrorhandling(ncid, PIO_BCAST_ERROR)
    ier = pio_inq_varid(ncid, name='SLOPE', vardesc=vardesc)
    if (ier /= PIO_noerr) then
       if (masterproc) write(iulog,*) subname//': variable SLOPE is not on dataset'
       readvar = .false.
    else
       readvar = .true.
    end if
    call pio_seterrorhandling(ncid, PIO_INTERNAL_ERROR)
    if (readvar) then
       ier = pio_inq_vardimid(ncid, vardesc, dids)
       allocate(compdof(rtmCTL%lnumr))
       cnt = 0
       do n = rtmCTL%begr,rtmCTL%endr
          cnt = cnt + 1
          compDOF(cnt) = rtmCTL%gindex(n)
       enddo
       call pio_initdecomp(pio_subsystem, pio_double, dids, compDOF, iodesc)
       deallocate(compdof)
       call pio_read_darray(ncid, vardesc, iodesc, rslope, ier)
       call pio_read_darray(ncid, vardesc, iodesc, max_volr, ier)
       call pio_freedecomp(ncid, iodesc)
    else
       rslope(:)   = 1._r8
       max_volr(:) = spval
    end if
    call pio_closefile(ncid)

    do nt = 1,nt_rtm
       do n = rtmCTL%begr, rtmCTL%endr
          fthresh(n) = 0.95*max_volr(n)*max(1._r8,rslope(n))
          ! modify velocity based on gridcell average slope (Manning eqn)
          evel(n,nt) = max(min_ev(nt),effvel(nt_rtm)*sqrt(max(0._r8,rslope(n)))) 
       end do
    end do

    deallocate(rslope, max_volr)

  end subroutine RtmFloodInit 

!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: 
!
! !INTERFACE:
  subroutine MOSART_init
!
! !REVISION HISTORY:
! Author: Hongyi Li

! !DESCRIPTION:
! initialize MOSART variables
! 
! !USES:
! !ARGUMENTS:
  implicit none
!
! !REVISION HISTORY:
! Author: Hongyi Li
!
!
! !OTHER LOCAL VARIABLES:
!EOP
  type(file_desc_t)  :: ncid       ! pio file desc
  type(var_desc_t)   :: vardesc    ! pio variable desc 
  type(io_desc_t)    :: iodesc_dbl ! pio io desc
  type(io_desc_t)    :: iodesc_int ! pio io desc
  integer, pointer   :: compdof(:) ! computational degrees of freedom for pio 
  integer :: dids(2)               ! variable dimension ids 
  integer :: dsizes(2)             ! variable dimension lengths
  integer  :: ier                           ! error code
  integer  :: begr, endr, iunit, nn, n, cnt
  character(len=32) :: subname = 'read_MOSART_inputs '
  character(len=1000) :: fname
  character(len=*),parameter :: FORMI = '(2A,2i10)'
  character(len=*),parameter :: FORMR = '(2A,2g15.7)'
 
  begr = rtmCTL%begr
  endr = rtmCTL%endr
  
  if(endr >= begr) then
     ! routing parameters
     call ncd_pio_openfile (ncid, trim(frivinp_rtm), 0)
     call pio_seterrorhandling(ncid, PIO_INTERNAL_ERROR)
     allocate(compdof(rtmCTL%lnumr))
     cnt = 0
     do n = rtmCTL%begr,rtmCTL%endr
        cnt = cnt + 1
        compDOF(cnt) = rtmCTL%gindex(n)
     enddo

     ! setup iodesc based on frac dids
     ier = pio_inq_varid(ncid, name='frac', vardesc=vardesc)
     ier = pio_inq_vardimid(ncid, vardesc, dids)
     ier = pio_inq_dimlen(ncid, dids(1),dsizes(1))
     ier = pio_inq_dimlen(ncid, dids(2),dsizes(2))
     call pio_initdecomp(pio_subsystem, pio_double, dsizes, compDOF, iodesc_dbl)
     call pio_initdecomp(pio_subsystem, pio_int   , dsizes, compDOF, iodesc_int)
     deallocate(compdof)
     call pio_seterrorhandling(ncid, PIO_BCAST_ERROR)

     allocate(TUnit%frac(begr:endr))
     ier = pio_inq_varid(ncid, name='frac', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%frac, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read frac ',minval(Tunit%frac),maxval(Tunit%frac)
     call shr_sys_flush(iulog)

     allocate(TUnit%fdir(begr:endr))  
     ier = pio_inq_varid(ncid, name='fdir', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_int, TUnit%fdir, ier)
     if (masterproc) write(iulog,FORMI) trim(subname),' read fdir ',minval(Tunit%fdir),maxval(Tunit%fdir)
     call shr_sys_flush(iulog)

     allocate(TUnit%mask(begr:endr))
     TUnit%mask = 1        ! assuming all spatial units are active land surface, TO DO

     allocate(TUnit%ID0(begr:endr))  
     ier = pio_inq_varid(ncid, name='ID', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_int, TUnit%ID0, ier)
     if (masterproc) write(iulog,FORMI) trim(subname),' read ID0 ',minval(Tunit%ID0),maxval(Tunit%ID0)
     call shr_sys_flush(iulog)

     allocate(TUnit%dnID(begr:endr))  
     ier = pio_inq_varid(ncid, name='dnID', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_int, TUnit%dnID, ier)
     if (masterproc) write(iulog,FORMI) trim(subname),' read dnID ',minval(Tunit%dnID),maxval(Tunit%dnID)
     call shr_sys_flush(iulog)

     allocate(TUnit%area(begr:endr))  
     ier = pio_inq_varid(ncid, name='area', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%area, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read area ',minval(Tunit%area),maxval(Tunit%area)
     call shr_sys_flush(iulog)

     allocate(TUnit%areaTotal(begr:endr))  
     ier = pio_inq_varid(ncid, name='areaTotal', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%areaTotal, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read areaTotal ',minval(Tunit%areaTotal),maxval(Tunit%areaTotal)
     call shr_sys_flush(iulog)

     allocate(TUnit%rlenTotal(begr:endr))
     TUnit%rlenTotal = 0._r8

     allocate(TUnit%nh(begr:endr))  
     ier = pio_inq_varid(ncid, name='nh', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%nh, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read nh ',minval(Tunit%nh),maxval(Tunit%nh)
     call shr_sys_flush(iulog)

     allocate(TUnit%hslp(begr:endr))  
     ier = pio_inq_varid(ncid, name='hslp', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%hslp, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read hslp ',minval(Tunit%hslp),maxval(Tunit%hslp)
     call shr_sys_flush(iulog)

     allocate(TUnit%gxr(begr:endr))  
     ier = pio_inq_varid(ncid, name='gxr', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%gxr, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read gxr ',minval(Tunit%gxr),maxval(Tunit%gxr)
     call shr_sys_flush(iulog)

     allocate(TUnit%hlen(begr:endr))
     TUnit%hlen = 0._r8

     allocate(TUnit%tslp(begr:endr))  
     ier = pio_inq_varid(ncid, name='tslp', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%tslp, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read tslp ',minval(Tunit%tslp),maxval(Tunit%tslp)
     call shr_sys_flush(iulog)

     allocate(TUnit%tlen(begr:endr))
     TUnit%tlen = 0._r8

     allocate(TUnit%twidth(begr:endr))  
     ier = pio_inq_varid(ncid, name='twid', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%twidth, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read twidth ',minval(Tunit%twidth),maxval(Tunit%twidth)
     call shr_sys_flush(iulog)

     allocate(TUnit%nt(begr:endr))  
     ier = pio_inq_varid(ncid, name='nt', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%nt, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read nt ',minval(Tunit%nt),maxval(Tunit%nt)
     call shr_sys_flush(iulog)

     allocate(TUnit%rlen(begr:endr))  
     ier = pio_inq_varid(ncid, name='rlen', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%rlen, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read rlen ',minval(Tunit%rlen),maxval(Tunit%rlen)
     call shr_sys_flush(iulog)

     allocate(TUnit%rslp(begr:endr))  
     ier = pio_inq_varid(ncid, name='rslp', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%rslp, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read rslp ',minval(Tunit%rslp),maxval(Tunit%rslp)
     call shr_sys_flush(iulog)

     allocate(TUnit%rwidth(begr:endr))  
     ier = pio_inq_varid(ncid, name='rwid', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%rwidth, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read rwidth ',minval(Tunit%rwidth),maxval(Tunit%rwidth)
     call shr_sys_flush(iulog)

     allocate(TUnit%rwidth0(begr:endr))  
     ier = pio_inq_varid(ncid, name='rwid0', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%rwidth0, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read rwidth0 ',minval(Tunit%rwidth0),maxval(Tunit%rwidth0)
     call shr_sys_flush(iulog)

     allocate(TUnit%rdepth(begr:endr))  
     ier = pio_inq_varid(ncid, name='rdep', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%rdepth, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read rdepth ',minval(Tunit%rdepth),maxval(Tunit%rdepth)
     call shr_sys_flush(iulog)

     allocate(TUnit%nr(begr:endr))  
     ier = pio_inq_varid(ncid, name='nr', vardesc=vardesc)
     call pio_read_darray(ncid, vardesc, iodesc_dbl, TUnit%nr, ier)
     if (masterproc) write(iulog,FORMR) trim(subname),' read nr ',minval(Tunit%nr),maxval(Tunit%nr)
     call shr_sys_flush(iulog)

     allocate(TUnit%nUp(begr:endr))
     TUnit%nUp = 0

     allocate(TUnit%iUp(begr:endr,8))
     TUnit%iUp = 0

     allocate(TUnit%indexDown(begr:endr))
     TUnit%indexDown = 0

     ! initialize water states and fluxes
     allocate (TRunoff%wh(begr:endr,nt_rtm))
     TRunoff%wh = 0._r8

     allocate (TRunoff%dwh(begr:endr,nt_rtm))
     TRunoff%dwh = 0._r8

     allocate (TRunoff%yh(begr:endr,nt_rtm))
     TRunoff%yh = 0._r8

     allocate (TRunoff%qsur(begr:endr,nt_rtm))
     TRunoff%qsur = 0._r8

     allocate (TRunoff%qsub(begr:endr,nt_rtm))
     TRunoff%qsub = 0._r8

     allocate (TRunoff%qgwl(begr:endr,nt_rtm))
     TRunoff%qgwl = 0._r8

     allocate (TRunoff%ehout(begr:endr,nt_rtm))
     TRunoff%ehout = 0._r8

     allocate (TRunoff%tarea(begr:endr,nt_rtm))
     TRunoff%tarea = 0._r8

     allocate (TRunoff%wt(begr:endr,nt_rtm))
     TRunoff%wt= 0._r8

     allocate (TRunoff%dwt(begr:endr,nt_rtm))
     TRunoff%dwt = 0._r8

     allocate (TRunoff%yt(begr:endr,nt_rtm))
     TRunoff%yt = 0._r8

     allocate (TRunoff%mt(begr:endr,nt_rtm))
     TRunoff%mt = 0._r8

     allocate (TRunoff%rt(begr:endr,nt_rtm))
     TRunoff%rt = 0._r8

     allocate (TRunoff%pt(begr:endr,nt_rtm))
     TRunoff%pt = 0._r8

     allocate (TRunoff%vt(begr:endr,nt_rtm))
     TRunoff%vt = 0._r8

     allocate (TRunoff%tt(begr:endr,nt_rtm))
     TRunoff%tt = 0._r8

     allocate (TRunoff%etin(begr:endr,nt_rtm))
     TRunoff%etin = 0._r8

     allocate (TRunoff%etout(begr:endr,nt_rtm))
     TRunoff%etout = 0._r8

     allocate (TRunoff%rarea(begr:endr,nt_rtm))
     TRunoff%rarea = 0._r8

     allocate (TRunoff%wr(begr:endr,nt_rtm))
     TRunoff%wr = 0._r8

     allocate (TRunoff%dwr(begr:endr,nt_rtm))
     TRunoff%dwr = 0._r8

     allocate (TRunoff%yr(begr:endr,nt_rtm))
     TRunoff%yr = 0._r8

     allocate (TRunoff%mr(begr:endr,nt_rtm))
     TRunoff%mr = 0._r8

     allocate (TRunoff%rr(begr:endr,nt_rtm))
     TRunoff%rr = 0._r8

     allocate (TRunoff%pr(begr:endr,nt_rtm))
     TRunoff%pr = 0._r8

     allocate (TRunoff%vr(begr:endr,nt_rtm))
     TRunoff%vr = 0._r8

     allocate (TRunoff%tr(begr:endr,nt_rtm))
     TRunoff%tr = 0._r8

     allocate (TRunoff%erlg(begr:endr,nt_rtm))
     TRunoff%erlg = 0._r8

     allocate (TRunoff%erlateral(begr:endr,nt_rtm))
     TRunoff%erlateral = 0._r8

     allocate (TRunoff%erin(begr:endr,nt_rtm))
     TRunoff%erin = 0._r8

     allocate (TRunoff%erout(begr:endr,nt_rtm))
     TRunoff%erout = 0._r8

     allocate (TRunoff%ergwl(begr:endr,nt_rtm))
     TRunoff%ergwl = 0._r8

     allocate (TRunoff%flow(begr:endr,nt_rtm))
     TRunoff%flow = 0._r8
    
     allocate (TPara%c_twid(begr:endr))
     TPara%c_twid = 1.0_r8

     call pio_freedecomp(ncid, iodesc_dbl)
     call pio_freedecomp(ncid, iodesc_int)
     call pio_closefile(ncid)

   ! control parameters and some other derived parameters
   ! estimate derived input variables

     do iunit=rtmCTL%begr,rtmCTL%endr
        if(TUnit%Gxr(iunit) > 0._r8) then
           TUnit%rlenTotal(iunit) = TUnit%area(iunit)*TUnit%Gxr(iunit)
        end if
     end do

     do iunit=rtmCTL%begr,rtmCTL%endr
        if(TUnit%rlen(iunit) > TUnit%rlenTotal(iunit)) then
           TUnit%rlenTotal(iunit) = TUnit%rlen(iunit)
        end if
     end do     

     do iunit=rtmCTL%begr,rtmCTL%endr
      
        if(TUnit%rlen(iunit) > 0._r8) then
           TUnit%hlen(iunit) = TUnit%area(iunit) / TUnit%rlenTotal(iunit) / 2._r8
           if(TUnit%hlen(iunit) > 50000_r8) then
              TUnit%hlen(iunit) = 50000_r8   ! allievate the outlier in drainage density estimation. TO DO
           end if
           TUnit%tlen(iunit) = TUnit%area(iunit) / TUnit%rlen(iunit) / 2._r8 - TUnit%hlen(iunit)
           if(TUnit%twidth(iunit) < 0._r8) then
              TUnit%twidth(iunit) = 0._r8
           end if
           if(TUnit%tlen(iunit) > 0._r8 .and. (TUnit%rlenTotal(iunit)-TUnit%rlen(iunit))/TUnit%tlen(iunit) > 1._r8) then
              TUnit%twidth(iunit) = TPara%c_twid(iunit)*TUnit%twidth(iunit)*((TUnit%rlenTotal(iunit)-TUnit%rlen(iunit))/TUnit%tlen(iunit))
           end if
          
           if(TUnit%tlen(iunit) > 0._r8 .and. TUnit%twidth(iunit) <= 0._r8) then
              TUnit%twidth(iunit) = 0._r8
           end if
        else
           TUnit%hlen(iunit) = 0._r8
           TUnit%tlen(iunit) = 0._r8
           TUnit%twidth(iunit) = 0._r8
        end if
        
        if(TUnit%rslp(iunit) <= 0._r8) then
           TUnit%rslp(iunit) = 0.0001_r8
        end if
        if(TUnit%tslp(iunit) <= 0._r8) then
           TUnit%tslp(iunit) = 0.0001_r8
        end if
        if(TUnit%hslp(iunit) <= 0._r8) then
           TUnit%hslp(iunit) = 0.005_r8
        end if
     end do

     do iunit=rtmCTL%begr,rtmCTL%endr
     do nn=rtmCTL%begr,rtmCTL%endr
        if(TUnit%dnID(iunit) == TUnit%ID0(nn)) then
           TUnit%indexDown(iunit) = nn
        end if
     end do
     end do
      
     ! this part needs to modified for grid-based representation
     do iunit=rtmCTL%begr,rtmCTL%endr
     do nn=rtmCTL%begr,rtmCTL%endr
        if(TUnit%dnID(iunit) == TUnit%ID0(nn)) then
           TUnit%nUp(nn) = TUnit%nUp(nn) + 1
           TUnit%iUp(nn,TUnit%nUp(nn)) = iunit
        end if
     end do
     end do
  end if

  ! control parameters
  Tctl%RoutingMethod = 1
  !Tctl%DATAH = rtm_nsteps*get_step_size()
  !Tctl%DeltaT = 60._r8  !
  !   if(Tctl%DATAH > 0 .and. Tctl%DATAH < Tctl%DeltaT) then
  !       Tctl%DeltaT = Tctl%DATAH
  !   end if      
  Tctl%DLevelH2R = 5
  Tctl%DLevelR = 3
  call SubTimestep ! prepare for numerical computation
    
  !if(masterproc) then
  !    fname = '/lustre/liho745/DCLM_model/ccsm_hy/run/clm_MOSART_subw2/run/test.dat'
  !    call createFile(1111,fname)
  !end if

  end subroutine MOSART_init

!----------------------------------------------------------------------------

  subroutine SubTimestep
  ! !DESCRIPTION: predescribe the sub-time-steps for channel routing
    implicit none    
    integer :: iunit   !local index

    allocate(TUnit%numDT_r(rtmCTL%begr:rtmCTL%endr),TUnit%numDT_t(rtmCTL%begr:rtmCTL%endr))
    TUnit%numDT_r = 1
    TUnit%numDT_t = 1
    allocate(TUnit%phi_r(rtmCTL%begr:rtmCTL%endr),TUnit%phi_t(rtmCTL%begr:rtmCTL%endr))
    TUnit%phi_r = 0._r8
    TUnit%phi_t = 0._r8
    
    do iunit=rtmCTL%begr,rtmCTL%endr
       if(TUnit%fdir(iunit) > 0 .and. TUnit%rlen(iunit) > 0._r8) then
          TUnit%phi_r(iunit) = TUnit%areaTotal(iunit)*sqrt(TUnit%rslp(iunit))/(TUnit%rlen(iunit)*TUnit%rwidth(iunit))
          if(TUnit%phi_r(iunit) >= 10._r8) then
             TUnit%numDT_r(iunit) = (TUnit%numDT_r(iunit)*log10(TUnit%phi_r(iunit))*Tctl%DLevelR) + 1
          else 
             TUnit%numDT_r(iunit) = TUnit%numDT_r(iunit)*1.0_r8*Tctl%DLevelR + 1
          end if
       end if
       if(TUnit%numDT_r(iunit) < 1) TUnit%numDT_r(iunit) = 1
      
       if(TUnit%tlen(iunit) > 0._r8) then
          TUnit%phi_t(iunit) =      TUnit%area(iunit)*sqrt(TUnit%tslp(iunit))/(TUnit%tlen(iunit)*TUnit%twidth(iunit))
          if(TUnit%phi_t(iunit) >= 10._r8) then 
             TUnit%numDT_t(iunit) = (TUnit%numDT_t(iunit)*log10(TUnit%phi_t(iunit))*Tctl%DLevelR) + 1
          else 
             TUnit%numDT_t(iunit) = (TUnit%numDT_t(iunit)*1.0*Tctl%DLevelR) + 1
          end if
       end if
       if(TUnit%numDT_t(iunit) < 1) TUnit%numDT_t(iunit) = 1
    end do
  end subroutine SubTimestep

!-----------------------------------------------------------------------

end module RtmMod


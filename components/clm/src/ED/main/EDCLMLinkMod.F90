module EDCLMLinkMod

  ! ============================================================================
  ! Modules to control the passing of infomation generated by ED into CLM to be used for either 
  ! diagnostics, or as input to the land surface components. 
  ! ============================================================================

  use shr_kind_mod     , only : r8 => shr_kind_r8
  use shr_infnan_mod, only : isnan => shr_infnan_isnan
  use decompMod        , only : bounds_type
  use clm_varpar       , only : numpft, numcft, mxpft
  use clm_varctl       , only : iulog 
  use ColumnType       , only : col
  use EDtypesMod       , only : ed_site_type, ed_cohort_type, ed_patch_type, ncwd
  use EDtypesMod       , only : sclass_ed, nlevsclass_ed, AREA, cp_nclmax, cp_nlevcan
  use CanopyStateType  , only : canopystate_type
  use clm_varctl       , only : use_vertsoilc
  use EDParamsMod      , only : ED_val_ag_biomass
  use SoilBiogeochemCarbonFluxType    , only : soilbiogeochem_carbonflux_type
  use SoilBiogeochemCarbonStatetype   , only : soilbiogeochem_carbonstate_type
  use clm_time_manager       , only : is_beg_curr_day, get_step_size, get_nstep
  use shr_const_mod, only: SHR_CONST_CDAY
  use abortutils      , only : endrun
  use shr_log_mod     , only : errMsg => shr_log_errMsg    
  use EDCanopyStructureMod, only : calc_areaindex

  !
  implicit none
  private
  !
  logical :: DEBUG = .false.  ! for debugging this module (EDCLMLinkMod.F90)
  
  ! !PUBLIC DATA MEMBERS 
  real(r8), public :: cwd_fcel_ed  
  real(r8), public :: cwd_flig_ed

  type, public :: ed_clm_type


     real(r8), pointer, private  :: daily_temp_patch           (:)   ! daily temperature for fire and phenology models
     real(r8), pointer, private  :: daily_rh_patch             (:)   ! daily RH for fire model
     real(r8), pointer, private  :: daily_prec_patch           (:)   ! daily rain for fire and phenology models. 

     !seed model. Aggregated to gridcell for now. 

     ! RGK: LEAVING SOME OLD DEFINITIONS IN UNTIL UNIT DISCREPANCIES ARE RECTIFIED

!     real(r8), pointer, private  :: seed_bank_patch            (:)   ! kGC/m2      Mass of seeds.                 
!     real(r8), pointer, private  :: seeds_in_patch             (:)   ! kGC/m2/year Production of seed mass.       
!     real(r8), pointer, private  :: seed_decay_patch           (:)   ! kGC/m2/year Decay of seed mass.            
!     real(r8), pointer, private  :: seed_germination_patch     (:)   ! kGC/m2/year Germiantion rate of seed mass. 
!     real(r8), pointer, private  :: ED_bstore_patch            (:)   ! kGC/m2 Total stored biomass. 
!     real(r8), pointer, private  :: ED_bdead_patch             (:)   ! kGC/m2 Total dead biomass.   
!     real(r8), pointer, private  :: ED_balive_patch            (:)   ! kGC/m2 Total alive biomass.  
!     real(r8), pointer, private  :: ED_bleaf_patch             (:)   ! kGC/m2 Total leaf biomass.   
!     real(r8), pointer, private  :: ED_biomass_patch           (:)   ! kGC/m2 Total biomass.        
!     Vegetation carbon fluxes at the patch scale
!     real(r8), pointer, private  :: npp_patch                  (:)   ! (gC/m2/s) patch net primary production
!     real(r8), pointer, private  :: gpp_patch                  (:)   ! (gC/m2/s) patch gross primary production 
!     real(r8), pointer, private  :: ar_patch                   (:)   ! (gC/m2/s) patch autotrophic respiration
!     real(r8), pointer, private  :: maint_resp_patch           (:)   ! (gC/m2/s) patch maintenance respiration
!     real(r8), pointer, private  :: growth_resp_patch          (:)   ! (gC/m2/s) patch growth respiration
     
     ! summary carbon fluxes at the column level
     real(r8), pointer,  private :: nep_col(:)                       ! [gC/m2/s] Net ecosystem production, i.e. fast-timescale carbon balance that does not include disturbance
     real(r8), pointer,  private :: nep_timeintegrated_col(:)                       ! [gC/m2/s] Net ecosystem production, i.e. fast-timescale carbon balance that does not include disturbance
     real(r8), pointer,  private :: npp_timeintegrated_col(:)                       ! [gC/m2/s] Net primary production, time integrated at column level for carbon balance checking
     real(r8), pointer,  private :: hr_timeintegrated_col(:)                        ! [gC/m2/s] heterotrophic respiration, time integrated for carbon balance checking
     real(r8), pointer,  private :: nbp_col(:)                       ! [gC/m2/s] Net biosphere production, i.e. slow-timescale carbon balance that integrates to total carbon change
     real(r8), pointer,  private :: npp_col(:)                ! [gC/m2/s] Net primary production at the fast timescale, aggregated to the column level
     real(r8), pointer,  private :: fire_c_to_atm_col(:)             ! [gC/m2/s] total fire carbon loss to atmosphere
     real(r8), pointer,  private :: ed_to_bgc_this_edts_col(:)       ! [gC/m2/s] total flux of carbon from ED to BGC models on current ED timestep
     real(r8), pointer,  private :: ed_to_bgc_last_edts_col(:)       ! [gC/m2/s] total flux of carbon from ED to BGC models on prior ED timestep
     real(r8), pointer,  private :: seed_rain_flux_col(:)            ! [gC/m2/s] total flux of carbon from seed rain
     
     ! summary carbon states at the column level
     real(r8), pointer,  private :: totecosysc_col(:)                ! [gC/m2] Total ecosystem carbon at the column level, including vegetation, CWD, litter, and soil pools
     real(r8), pointer,  private :: totecosysc_old_col(:)            ! [gC/m2] Total ecosystem C at the column level from last call to balance check
     real(r8), pointer,  private :: totedc_col(:)                    ! [gC/m2] Total ED carbon at the column level, including vegetation, CWD, seeds, and ED litter
     real(r8), pointer,  private :: totedc_old_col(:)                ! [gC/m2] Total ED C at the column level from last call to balance check
     real(r8), pointer,  private :: totbgcc_col(:)                   ! [gC/m2] Total BGC carbon at the column level, including litter, and soil pools
     real(r8), pointer,  private :: totbgcc_old_col(:)               ! [gC/m2] Total BGC C at the column level from last call to balance check
     real(r8), pointer,  private :: biomass_stock_col(:)             ! [gC/m2] total biomass at the column level in gC / m2
     real(r8), pointer,  private :: ed_litter_stock_col(:)           ! [gC/m2] ED litter at the column level in gC / m2
     real(r8), pointer,  private :: cwd_stock_col(:)                 ! [gC/m2] ED CWD at the column level in gC / m2
     real(r8), pointer,  private :: seed_stock_col(:)                ! [gC/m2] ED seed mass carbon at the column level in gC / m2

     ! carbon balance errors.  at some point we'll reduce these to close to zero and delete, but for now we'll just keep[ track of them
     real(r8), pointer,  private :: cbalance_error_ed_col(:)         ! [gC/m2/s]  total carbon balance error for the ED side
     real(r8), pointer,  private :: cbalance_error_bgc_col(:)        ! [gC/m2/s]  total carbon balance error for the BGC side
     real(r8), pointer,  private :: cbalance_error_total_col(:)      ! [gC/m2/s]  total carbon balance error for the whole thing

     ! ED patch/cohort data
     real(r8), pointer,  private :: ed_npatches_col(:)               ! [#] the number of patches per ED site
     real(r8), pointer,  private :: ed_ncohorts_col(:)               ! [#] the number of cohorts per ED site     

   contains

     ! Public routines
     procedure , public  :: Init   
     procedure , public  :: Restart
     procedure , public  :: ed_clm_link
     procedure , public  :: SummarizeNetFluxes
!     procedure , public  :: SummarizeProductivityFluxes     
     procedure , public  :: ED_BGC_Carbon_Balancecheck

     ! Private routines
     procedure , private :: ed_clm_leaf_area_profile
     procedure , private :: InitAllocate 
     procedure , private :: InitHistory

  end type ed_clm_type

  ! 10/30/09: Created by Rosie Fisher
  !-----------------------------------------------------------------------

contains

  !------------------------------------------------------------------------
  subroutine Init(this, bounds)
    !
    ! !DESCRIPTION:
    ! Initialize module data structure instance
    !
    ! !ARGUMENTS:
    class(ed_clm_type) :: this
    type(bounds_type), intent(in) :: bounds  
    !-----------------------------------------------------------------------

    call this%InitAllocate(bounds)
    call this%InitHistory(bounds)

  end subroutine Init

  !------------------------------------------------------------------------
  subroutine InitAllocate(this, bounds)
    !
    ! !USES: 
    use shr_infnan_mod , only : nan => shr_infnan_nan, assignment(=)
    use clm_varpar     , only : nlevgrnd, nlevdecomp_full
    use EDtypesMod     , only : numpft_ed
    !
    ! !ARGUMENTS:
    class (ed_clm_type) :: this 
    type(bounds_type), intent(in)    :: bounds 
    !
    ! !LOCAL VARIABLES:
    integer           :: begp,endp
    integer           :: begc,endc                                    !bounds
    integer           :: begg,endg
    !------------------------------------------------------------------------

    begp = bounds%begp; endp = bounds%endp
    begc = bounds%begc; endc = bounds%endc

    allocate(this%ed_to_bgc_this_edts_col    (begc:endc))            ; this%ed_to_bgc_this_edts_col   (:) = nan
    allocate(this%ed_to_bgc_last_edts_col    (begc:endc))            ; this%ed_to_bgc_last_edts_col   (:) = nan
    allocate(this%seed_rain_flux_col         (begc:endc))            ; this%seed_rain_flux_col        (:) = nan

    allocate(this%nep_col                    (begc:endc))            ; this%nep_col                   (:) = nan
    allocate(this%nep_timeintegrated_col     (begc:endc))            ; this%nep_timeintegrated_col    (:) = nan
    allocate(this%npp_timeintegrated_col     (begc:endc))            ; this%npp_timeintegrated_col    (:) = nan
    allocate(this%hr_timeintegrated_col     (begc:endc))            ; this%hr_timeintegrated_col    (:) = nan

    allocate(this%nbp_col                    (begc:endc))            ; this%nbp_col                   (:) = nan
    allocate(this%npp_col                    (begc:endc))            ; this%npp_col                   (:) = nan
    allocate(this%fire_c_to_atm_col          (begc:endc))            ; this%fire_c_to_atm_col         (:) = nan

    allocate(this%totecosysc_col             (begc:endc))            ; this%totecosysc_col            (:) = nan
    allocate(this%totecosysc_old_col         (begc:endc))            ; this%totecosysc_old_col        (:) = nan
    allocate(this%totedc_col             (begc:endc))            ; this%totedc_col            (:) = nan
    allocate(this%totedc_old_col         (begc:endc))            ; this%totedc_old_col        (:) = nan
    allocate(this%totbgcc_col             (begc:endc))            ; this%totbgcc_col            (:) = nan
    allocate(this%totbgcc_old_col         (begc:endc))            ; this%totbgcc_old_col        (:) = nan
    allocate(this%biomass_stock_col          (begc:endc))            ; this%biomass_stock_col         (:) = nan
    allocate(this%ed_litter_stock_col        (begc:endc))            ; this%ed_litter_stock_col       (:) = nan
    allocate(this%cwd_stock_col              (begc:endc))            ; this%cwd_stock_col             (:) = nan
    allocate(this%seed_stock_col             (begc:endc))            ; this%seed_stock_col            (:) = nan

    allocate(this%cbalance_error_ed_col      (begc:endc))            ; this%cbalance_error_ed_col     (:) = nan    
    allocate(this%cbalance_error_bgc_col     (begc:endc))            ; this%cbalance_error_bgc_col    (:) = nan    
    allocate(this%cbalance_error_total_col   (begc:endc))            ; this%cbalance_error_total_col  (:) = nan    

  end subroutine InitAllocate

  !------------------------------------------------------------------------
  subroutine InitHistory(this, bounds)
    !
    ! !DESCRIPTION:
    ! add history fields for all variables, always set as default='inactive'
    !
    ! !USES:
    use clm_varpar , only : ndecomp_cascade_transitions, ndecomp_pools
    use clm_varpar , only : nlevdecomp, nlevdecomp_full
    use clm_varcon , only : spval
    use histFileMod, only : hist_addfld1d, hist_addfld2d, hist_addfld_decomp 
    !
    ! !ARGUMENTS:
    class(ed_clm_type) :: this    
    type(bounds_type)         , intent(in) :: bounds 
    !
    ! !LOCAL VARIABLES:
    integer           :: k,l,ii,jj 
    character(8)      :: vr_suffix
    character(10)     :: active
    integer           :: begp,endp
    integer           :: begc,endc
    character(24)     :: fieldname
    character(100)    :: longname
    real(r8), pointer :: data1dptr(:)   ! temp. pointer for slicing larger arrays
    !---------------------------------------------------------------------

    begp = bounds%begp; endp = bounds%endp
    begc = bounds%begc; endc = bounds%endc

    this%nep_col(begc:endc) = spval
    call hist_addfld1d (fname='NEP', units='gC/m^2/s', &
         avgflag='A', long_name='net ecosystem production', &
         ptr_col=this%nep_col)

    this%fire_c_to_atm_col(begc:endc) = spval
    call hist_addfld1d (fname='Fire_Closs', units='gC/m^2/s', &
         avgflag='A', long_name='ED/SPitfire Carbon loss to atmosphere', &
         ptr_col=this%fire_c_to_atm_col)

    this%nbp_col(begc:endc) = spval
    call hist_addfld1d (fname='NBP', units='gC/m^2/s', &
         avgflag='A', long_name='net biosphere production', &
         ptr_col=this%nbp_col)

    this%totecosysc_col(begc:endc) = spval
    call hist_addfld1d (fname='TOTECOSYSC', units='gC/m^2', &
         avgflag='A', long_name='total ecosystem carbon', &
         ptr_col=this%totecosysc_col)

    this%cbalance_error_ed_col(begc:endc) = spval
    call hist_addfld1d (fname='CBALANCE_ERROR_ED', units='gC/m^2/s', &
         avgflag='A', long_name='total carbon balance error on ED side', &
         ptr_col=this%cbalance_error_ed_col)

    this%cbalance_error_bgc_col(begc:endc) = spval
    call hist_addfld1d (fname='CBALANCE_ERROR_BGC', units='gC/m^2/s', &
         avgflag='A', long_name='total carbon balance error on BGC side', &
         ptr_col=this%cbalance_error_bgc_col)

    this%cbalance_error_total_col(begc:endc) = spval
    call hist_addfld1d (fname='CBALANCE_ERROR_TOTAL', units='gC/m^2/s', &
         avgflag='A', long_name='total carbon balance error total', &
         ptr_col=this%cbalance_error_total_col)

    this%biomass_stock_col(begc:endc) = spval
    call hist_addfld1d (fname='BIOMASS_STOCK_COL', units='gC/m^2', &
         avgflag='A', long_name='total ED biomass carbon at the column level', &
         ptr_col=this%biomass_stock_col)

    this%ed_litter_stock_col(begc:endc) = spval
    call hist_addfld1d (fname='ED_LITTER_STOCK_COL', units='gC/m^2', &
         avgflag='A', long_name='total ED litter carbon at the column level', &
         ptr_col=this%ed_litter_stock_col)

    this%cwd_stock_col(begc:endc) = spval
    call hist_addfld1d (fname='CWD_STOCK_COL', units='gC/m^2', &
         avgflag='A', long_name='total CWD carbon at the column level', &
         ptr_col=this%cwd_stock_col)

    this%seed_stock_col(begc:endc) = spval
    call hist_addfld1d (fname='SEED_STOCK_COL', units='gC/m^2', &
         avgflag='A', long_name='total seed carbon at the column level', &
         ptr_col=this%seed_stock_col)

  end subroutine InitHistory

  !-----------------------------------------------------------------------
  ! subroutine InitCold(this, bounds)
  !   !
  !   ! !DESCRIPTION:
  !   ! Initialize relevant time varying variables
  !   !
  !   ! !ARGUMENTS:
  !   class (ed_clm_type) :: this
  !   type(bounds_type), intent(in) :: bounds  
  !   !
  !   ! !LOCAL VARIABLES:
  !   integer :: p
  !   !-----------------------------------------------------------------------

  !   ! do p = bounds%begp,bounds%endp
  !   !    this%dispvegc_patch(p) = 0._r8 
  !   !    this%storvegc_patch(p) = 0._r8 
  !   ! end do

  ! end subroutine InitCold
  !-----------------------------------------------------------------------
  subroutine Restart ( this,  bounds, ncid, flag )
    !
    ! !DESCRIPTION: 
    ! Read/write restart data 
    !
    ! !USES:
    use restUtilMod
    use ncdio_pio
    ! use EDtypesMod           , only : numpft_ed

    !
    ! !ARGUMENTS:
    class (ed_clm_type) :: this
    type(bounds_type) , intent(in)    :: bounds 
    type(file_desc_t) , intent(inout) :: ncid   
    character(len=*)  , intent(in)    :: flag   !'read' or 'write' or 'define'
    !
    ! !LOCAL VARIABLES:
    logical            :: readvar
    real(r8), pointer :: ptr2d(:,:) ! temp. pointers for slicing larger arrays
    real(r8), pointer :: ptr1d(:)   ! temp. pointers for slicing larger arrays  
    ! character(LEN=3)   :: istr1
    ! integer            :: k
    !------------------------------------------------------------------------

    ptr1d => this%nep_timeintegrated_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='nep_timeintegrated_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 

    ptr1d => this%npp_timeintegrated_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='npp_timeintegrated_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 

    ptr1d => this%hr_timeintegrated_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='hr_timeintegrated_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 

    ptr1d => this%totecosysc_old_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='totecosysc_old_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 
    
    ptr1d => this%cbalance_error_ed_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='cbalance_error_ed_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 
    
    ptr1d => this%cbalance_error_bgc_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='cbalance_error_bgc_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 
    
    ptr1d => this%cbalance_error_total_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='cbalance_error_total_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 
    
    ptr1d => this%totedc_old_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='totedc_old_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 
    
    ptr1d => this%totbgcc_old_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='totbgcc_old_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 
    
    ptr1d => this%ed_to_bgc_this_edts_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='ed_to_bgc_this_edts_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 
    
    ptr1d => this%ed_to_bgc_last_edts_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='ed_to_bgc_last_edts_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 

    ptr1d => this%seed_rain_flux_col(:)
    call restartvar(ncid=ncid, flag=flag, varname='seed_rain_flux_col', xtype=ncd_double,  &
         dim1name='column', long_name='', units='', &
         interpinic_flag='interp', readvar=readvar, data=ptr1d) 
    

  end subroutine Restart

  !-----------------------------------------------------------------------

  subroutine ed_clm_link( this, bounds, sites, nsites, fcolumn, waterstate_inst, canopystate_inst)
    !
    ! !USES: 
    use landunit_varcon      , only : istsoil
    use EDGrowthFunctionsMod , only : tree_lai, c_area
    use EDEcophysConType     , only : EDecophyscon
    use EDtypesMod           , only : area
    use PatchType            , only : clmpatch => patch
    use LandunitType         , only : lun
    use pftconMod            , only : pftcon
    use CanopyStateType      , only : canopystate_type
    use WaterStateType       , only : waterstate_type

    ! !ARGUMENTS    
    class(ed_clm_type)                              :: this
    type(bounds_type)       , intent(in)            :: bounds  
    type(ed_site_type)      , intent(inout), target :: sites(nsites)
    integer                 , intent(in)            :: nsites
    integer                 , intent(in)            :: fcolumn(nsites)
    type(waterstate_type)   , intent(inout)         :: waterstate_inst
    type(canopystate_type)  , intent(inout)         :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    type (ed_patch_type)  , pointer :: currentPatch
    type (ed_cohort_type) , pointer :: currentCohort
    integer  :: g,l,p,c,s
    integer  :: ft                                      ! plant functional type
    integer  :: patchn                                  ! identification number for each patch. 
    real(r8) :: total_bare_ground                       ! sum of the bare fraction in all pfts.
    real(r8) :: total_patch_area                               
    real(r8) :: coarse_wood_frac  
    real(r8) :: canopy_leaf_area                        ! total amount of leaf area in the vegetated area. m2.  
    integer  :: begp_fp, endp_fp                        ! Valid range of patch indices that are associated with 
                                                        ! FATES (F) for each parent (P) iteration (grid/column)
    !----------------------------------------------------------------------

    if ( DEBUG ) then
       write(iulog,*) 'in ed_clm_link'
    endif

    associate(                                 & 
         tlai => canopystate_inst%tlai_patch , &
         elai => canopystate_inst%elai_patch , &
         tsai => canopystate_inst%tsai_patch , &
         esai => canopystate_inst%esai_patch , &
         htop => canopystate_inst%htop_patch , &
         hbot => canopystate_inst%hbot_patch , & 
         begg => bounds%begg                 , &
         endg => bounds%endg                 , &
         begc => bounds%begc                 , &
         endc => bounds%endc                 , &
         begp => bounds%begp                 , &
         endp => bounds%endp                   &
         )


      do s = 1,nsites

         c = fcolumn(s)
         
         ! ============================================================================
         ! Zero the bare ground tile BGC variables.
         ! Valid Range for zero'ing here is the soil_patch and non crop patches
         ! If the crops are not turned on, don't worry, they were zero'd once and should
         ! not change again (RGK).
         ! col%patchi(c) + numpft - numcft
         ! ============================================================================
         
         begp_fp = col%patchi(c)
         endp_fp = col%patchi(c) + numpft - numcft
         
         clmpatch%is_veg(begp_fp:endp_fp)        = .false. 
         clmpatch%is_bareground(begp_fp:endp_fp) = .false. 

         tlai(begp_fp:endp_fp)                   = 0.0_r8    
         htop(begp_fp:endp_fp)                   = 0.0_r8      
         hbot(begp_fp:endp_fp)                   = 0.0_r8   
         elai(begp_fp:endp_fp)                   = 0.0_r8
         tsai(begp_fp:endp_fp)                   = 0.0_r8
         esai(begp_fp:endp_fp)                   = 0.0_r8
         
         
         patchn = 0
         total_bare_ground = 0.0_r8
         total_patch_area = 0._r8 

         currentPatch => sites(s)%oldest_patch
         do while(associated(currentPatch))
            patchn = patchn + 1
            currentPatch%patchno = patchn
            
            if (patchn <= numpft - numcft)then !don't expand into crop patches.   

               currentPatch%clm_pno = col%patchi(c) + patchn !the first 'soil' patch is unvegetated...      
               
               ! INTERF-TODO:  currentPatch%clm_pno should be removed (FATES internal variable with CLM iformation)
               
               p = col%patchi(c) + patchn
               
               if(c .ne. clmpatch%column(p))then
                  write(iulog,*) ' fcolumn(s) does not match clmpatch%column(p)'
                  call endrun(msg=errMsg(__FILE__, __LINE__))
               end if

               clmpatch%is_veg(p) = .true. !this .is. a tile filled with vegetation... 
               
               call currentPatch%set_root_fraction()

               !zero cohort-summed variables. 
               currentPatch%total_canopy_area = 0.0_r8
               currentPatch%total_tree_area = 0.0_r8
               currentPatch%lai = 0.0_r8
               canopy_leaf_area = 0.0_r8

               !update cohort quantitie s                                  
               currentCohort => currentPatch%shortest
               do while(associated(currentCohort))
     
                  ft = currentCohort%pft
                  currentCohort%livestemn = currentCohort%bsw  / pftcon%leafcn(currentCohort%pft)
                  
                  currentCohort%livecrootn = 0.0_r8

                  if (pftcon%woody(ft) == 1) then
                     coarse_wood_frac = 0.5_r8
                  else
                     coarse_wood_frac = 0.0_r8
                  end if
                  
                  if ( DEBUG ) then
                     write(iulog,*) 'EDCLMLink 618 ',currentCohort%livecrootn
                     write(iulog,*) 'EDCLMLink 619 ',currentCohort%br
                     write(iulog,*) 'EDCLMLink 620 ',coarse_wood_frac
                     write(iulog,*) 'EDCLMLink 621 ',pftcon%leafcn(ft)
                  endif

                  currentCohort%livecrootn = currentCohort%br * coarse_wood_frac / pftcon%leafcn(ft)

                  if ( DEBUG ) write(iulog,*) 'EDCLMLink 625 ',currentCohort%livecrootn

                  currentCohort%b = currentCohort%balive+currentCohort%bdead+currentCohort%bstore
                  currentCohort%treelai = tree_lai(currentCohort)

                  currentCohort%c_area = c_area(currentCohort)
                  canopy_leaf_area = canopy_leaf_area + currentCohort%treelai *currentCohort%c_area
                  
                  
                  if(currentCohort%canopy_layer==1)then
                     currentPatch%total_canopy_area = currentPatch%total_canopy_area + currentCohort%c_area
                     if(pftcon%woody(ft)==1)then
                        currentPatch%total_tree_area = currentPatch%total_tree_area + currentCohort%c_area
                     endif
                  endif

                  ! Check for erroneous zero values. 
                  if(currentCohort%dbh <= 0._r8 .or. currentCohort%n == 0._r8)then
                     write(iulog,*) 'ED: dbh or n is zero in clmedlink', currentCohort%dbh,currentCohort%n
                  endif
                  if(currentCohort%pft == 0.or.currentCohort%canopy_trim <= 0._r8)then
                     write(iulog,*) 'ED: PFT or trim is zero in clmedlink',currentCohort%pft,currentCohort%canopy_trim
                  endif
                  if(currentCohort%balive <= 0._r8)then
                     write(iulog,*) 'ED: balive is zero in clmedlink',currentCohort%balive
                  endif

                  currentCohort => currentCohort%taller
                  
               enddo ! ends 'do while(associated(currentCohort))

               if ( currentPatch%total_canopy_area-currentPatch%area > 0.000001_r8 ) then
                  write(iulog,*) 'ED: canopy area bigger than area',currentPatch%total_canopy_area ,currentPatch%area
                  currentPatch%total_canopy_area = currentPatch%area
               endif

               ! PASS BACK PATCH-LEVEL QUANTITIES THAT ARE NEEDED BY THE CLM CODE
               if (associated(currentPatch%tallest)) then
                  htop(p) = currentPatch%tallest%hite
               else
                  ! FIX(RF,040113) - should this be a parameter for the minimum possible vegetation height?
                  htop(p) = 0.1_r8
               endif

               hbot(p) = max(0._r8, min(0.2_r8, htop(p)- 1.0_r8))

               ! leaf area index: of .only. the areas with some vegetation on them, as the non-vegetated areas 
               ! are merged into the bare ground fraction. This introduces a degree of unrealism, 
               ! which could be fixed if the surface albedo routine took account of the possibiltiy of bare 
               ! ground mixed with trees. 
               
               if(currentPatch%total_canopy_area > 0)then;
                  tlai(p) = canopy_leaf_area/currentPatch%total_canopy_area 
               else
                  tlai(p) = 0.0_r8
               endif


               ! We are assuming here that grass is all located underneath tree canopies. 
               ! The alternative is to assume it is all spatial distinct from tree canopies.
               ! In which case, the bare area would have to be reduced by the grass area...
               ! currentPatch%total_canopy_area/currentPatch%area is fraction of this patch cover by plants 
               ! currentPatch%area/AREA is the fraction of the soil covered by this patch. 


               clmpatch%wt_ed(p) = min(1.0_r8,(currentPatch%total_canopy_area/currentPatch%area)) * &
                     (currentPatch%area/AREA)
               currentPatch%bare_frac_area = (1.0_r8 - min(1.0_r8,currentPatch%total_canopy_area/currentPatch%area)) * &
                     (currentPatch%area/AREA)                 
                  
               if ( DEBUG ) then
                  write(iulog, *) 'EDCLMLinkMod bare frac', currentPatch%bare_frac_area
               end if

               total_patch_area = total_patch_area + clmpatch%wt_ed(p) + currentPatch%bare_frac_area
               total_bare_ground = total_bare_ground + currentPatch%bare_frac_area
                  
            else
               write(iulog,*) 'ED: too many patches' 
            end if ! patchn<15
               
            currentPatch => currentPatch%younger
         end do !patch loop
            
         if((total_patch_area-1.0_r8)>1e-9)then
            write(iulog,*) 'total area is wrong in CLMEDLINK',total_patch_area
         endif
            
         ! loop round all and zero the remaining empty vegetation patches 
         ! while ED's domain of influence only extends to non-crop patches
         ! wt_ed should not be non-zero anwhere but ED patches, so this loop is ok
         do p = col%patchi(c)+patchn+1,col%patchi(c)+numpft   
            clmpatch%wt_ed(p) = 0.0_r8
         enddo

         !set the area of the bare ground patch. 
         p = col%patchi(c)
         clmpatch%wt_ed(p) = total_bare_ground
         clmpatch%is_bareground = .true.
            
         call this%ed_clm_leaf_area_profile(sites(s), c, waterstate_inst, canopystate_inst ) 
         
      end do ! column loop

    end associate

  end subroutine ed_clm_link

  !------------------------------------------------------------------------

  ! INTERF-TODO: THIS ROUTINE COULD BE SPLIT.  IT CALCULATES BOTH FATES/ED INTERNALS
  ! AS WELL AS VARIABLES FOR CLM/ALM.


  subroutine ed_clm_leaf_area_profile( this, currentSite, colindex, waterstate_inst, canopystate_inst )
    !
    ! !DESCRIPTION:
    ! Load LAI in each layer into array to send to CLM
    !
    ! !USES: 
    use EDGrowthFunctionsMod , only : tree_lai, tree_sai, c_area 
    use EDtypesMod           , only : area, dinc_ed, hitemax, numpft_ed, n_hite_bins
    use EDEcophysConType     , only : EDecophyscon
    use CanopyStateType      , only : canopystate_type
    use WaterStateType       , only : waterstate_type
    use PatchType            , only : clmpatch => patch
    !
    ! !ARGUMENTS    
    class(ed_clm_type)                     :: this  
    type(ed_site_type)     , intent(inout) :: currentSite
    integer                , intent(in)    :: colindex      ! ALM/CLM column index of this site
    type(waterstate_type)  , intent(inout) :: waterstate_inst
    type(canopystate_type) , intent(inout) :: canopystate_inst
    !
    ! !LOCAL VARIABLES:
    type (ed_patch_type)  , pointer :: currentPatch
    type (ed_cohort_type) , pointer :: currentCohort
    real(r8) :: remainder                !Thickness of layer at bottom of canopy. 
    real(r8) :: fleaf                    ! fraction of cohort incepting area that is leaves.  
    integer  :: ft                       ! Plant functional type index. 
    integer  :: iv                       ! Vertical leaf layer index   
    integer  :: L                        ! Canopy layer index
    integer  :: p                        ! clm patch index  

    real(r8) :: tlai_temp                ! calculation of tlai to check this method
    real(r8) :: elai_temp                ! make a new elai based on the layer-by-layer snow coverage.
    real(r8) :: tsai_temp                !
    real(r8) :: esai_temp                !  
    real(r8) :: fraction_exposed         ! how much of this layer is not covered by snow?
    real(r8) :: layer_top_hite           ! notional top height of this canopy layer (m)
    real(r8) :: layer_bottom_hite        ! notional bottom height of this canopy layer (m)
    integer  :: smooth_leaf_distribution ! is the leaf distribution this option (1) or not (0)
    real(r8) :: frac_canopy(N_HITE_BINS) ! amount of canopy in each height class
    real(r8) :: minh(N_HITE_BINS)        ! minimum height in height class (m)
    real(r8) :: maxh(N_HITE_BINS)        ! maximum height in height class (m)
    real(r8) :: dh                       ! vertical detph of height class (m)
    real(r8) :: min_chite                ! bottom of cohort canopy  (m)
    real(r8) :: max_chite                ! top of cohort canopy      (m)
    real(r8) :: lai                      ! summed lai for checking m2 m-2
    real(r8) :: snow_depth_col           ! averaged snow over whole columb
    integer  :: NC                       ! number of cohorts, for bug fixing. 
    
    !----------------------------------------------------------------------

    smooth_leaf_distribution = 0

    associate(                                                             & 
         snow_depth         => waterstate_inst%snow_depth_col            , & !Input:
         frac_sno_eff       => waterstate_inst%frac_sno_eff_col          , & !Input: 
         snowdp             => waterstate_inst%snowdp_col                , & !Output:
         
         frac_veg_nosno_alb => canopystate_inst%frac_veg_nosno_alb_patch , & !Output:
         tlai               => canopystate_inst%tlai_patch               , & !Output
         elai               => canopystate_inst%elai_patch               , & !Output
         tsai               => canopystate_inst%tsai_patch               , & !Output
         esai               => canopystate_inst%esai_patch                 & !Output
         )

      ! Here we are trying to generate a profile of leaf area, indexed by 'z' and by pft
      ! We assume that each point in the canopy recieved the light attenuated by the average
      ! leaf area index above it, irrespective of PFT identity... 
      ! Each leaf is defined by how deep in the canopy it is, in terms of LAI units.  (FIX(RF,032414), GB)

      currentPatch => currentSite%oldest_patch   ! ed patch
      p            =  col%patchi(colindex)       ! first patch of the column of interest, for vegetated
                                                 ! columns this is the non-veg patch

      ! Zero some soil values
      tlai(p) = 0.0_r8
      elai(p) = 0.0_r8
      tsai(p) = 0.0_r8
      esai(p) = 0.0_r8

      do while(associated(currentPatch))
         p = p + 1                               ! First CLM/ALM patch is non-veg, increment at loop start

         !Calculate tree and canopy areas. 
         currentPatch%canopy_area = 0._r8
         currentPatch%canopy_layer_lai(:) = 0._r8
         NC = 0
         currentCohort => currentPatch%shortest
         do while(associated(currentCohort))       
            currentCohort%c_area = c_area(currentCohort)
            currentPatch%canopy_area = currentPatch%canopy_area + currentCohort%c_area
            NC = NC+1
            currentCohort => currentCohort%taller    
         enddo
         ! if plants take up all the tile, then so does the canopy.  
         currentPatch%canopy_area = min(currentPatch%canopy_area,currentPatch%area) 
         
         !calculate tree lai and sai.
         currentPatch%ncan(:,:) = 0 
         currentPatch%nrad(:,:) = 0 
         currentPatch%lai = 0._r8
         currentCohort => currentPatch%shortest
         do while(associated(currentCohort)) 
            currentCohort%treelai = tree_lai(currentCohort)    
            currentCohort%treesai = tree_sai(currentCohort)
            currentCohort%lai =  currentCohort%treelai *currentCohort%c_area/currentPatch%canopy_area 
            currentCohort%sai =  currentCohort%treesai *currentCohort%c_area/currentPatch%canopy_area  
            !Calculate the LAI plus SAI in each canopy storey. 
            currentCohort%NV =  ceiling((currentCohort%treelai+currentCohort%treesai)/dinc_ed)  
            
            currentPatch%ncan(currentCohort%canopy_layer,currentCohort%pft) = &
                  max(currentPatch%ncan(currentCohort%canopy_layer,currentCohort%pft),currentCohort%NV)
            currentPatch%lai = currentPatch%lai +currentCohort%lai
            
            do L = 1,cp_nclmax-1
               if(currentCohort%canopy_layer == L)then
                  currentPatch%canopy_layer_lai(L) = currentPatch%canopy_layer_lai(L) + currentCohort%lai + &
                        currentCohort%sai
               endif
            enddo
            
            currentCohort => currentCohort%taller 
            
         enddo !currentCohort
         currentPatch%nrad = currentPatch%ncan

         if(smooth_leaf_distribution == 1)then
               ! we are going to ignore the concept of canopy layers, and put all of the leaf area into height banded bins. 
               ! using the same domains as we had before, except that CL always = 1
               currentPatch%tlai_profile = 0._r8
               currentPatch%tsai_profile = 0._r8  
               currentPatch%elai_profile = 0._r8
               currentPatch%esai_profile = 0._r8  

               ! this is a crude way of dividing up the bins. Should it be a function of actual maximum height? 
               dh = 1.0_r8*(HITEMAX/N_HITE_BINS) 
               do iv = 1,N_HITE_BINS  
                  if (iv == 1) then
                     minh(iv) = 0.0_r8
                     maxh(iv) = dh
                  else 
                     minh(iv) = (iv-1)*dh
                     maxh(iv) = (iv)*dh
                  endif
               enddo

               !c = clmpatch%column(currentPatch%clm_pno)

               currentCohort => currentPatch%shortest
               do while(associated(currentCohort))  
                  ft = currentCohort%pft
                  min_chite = currentCohort%hite - currentCohort%hite * EDecophyscon%crown(ft)
                  max_chite = currentCohort%hite  
                  do iv = 1,N_HITE_BINS  
                     frac_canopy(iv) = 0.0_r8
                     ! this layer is in the middle of the canopy
                     if(max_chite > maxh(iv).and.min_chite < minh(iv))then 
                        frac_canopy(iv)= min(1.0_r8,dh / (currentCohort%hite*EDecophyscon%crown(ft)))
                        ! this is the layer with the bottom of the canopy in it. 
                     elseif(min_chite < maxh(iv).and.min_chite > minh(iv).and.max_chite > maxh(iv))then 
                        frac_canopy(iv) = (maxh(iv) -min_chite ) / (currentCohort%hite*EDecophyscon%crown(ft))
                        ! this is the layer with the top of the canopy in it. 
                     elseif(max_chite > minh(iv).and.max_chite < maxh(iv).and.min_chite < minh(iv))then 
                        frac_canopy(iv) = (max_chite - minh(iv)) / (currentCohort%hite*EDecophyscon%crown(ft))
                     elseif(max_chite < maxh(iv).and.min_chite > minh(iv))then !the whole cohort is within this layer. 
                        frac_canopy(iv) = 1.0_r8
                     endif

                     ! no m2 of leaf per m2 of ground in each height class
                     currentPatch%tlai_profile(1,ft,iv) = currentPatch%tlai_profile(1,ft,iv) + frac_canopy(iv) * &
                          currentCohort%lai
                     currentPatch%tsai_profile(1,ft,iv) = currentPatch%tsai_profile(1,ft,iv) + frac_canopy(iv) * &
                          currentCohort%sai

                     !snow burial
!write(*,*) 'calc snow'
                     snow_depth_col = snow_depth(colindex) * frac_sno_eff(colindex)
                     if(snow_depth_col  > maxh(iv))then
                        fraction_exposed = 0._r8
                     endif
                     if(snow_depth_col < minh(iv))then
                       fraction_exposed = 1._r8
                     endif
                     if(snow_depth_col>= minh(iv).and.snow_depth_col <= maxh(iv))then !only partly hidden... 
                        fraction_exposed =  max(0._r8,(min(1.0_r8,(snow_depth_col-minh(iv))/dh)))
                     endif
                     fraction_exposed = 1.0_r8
                     ! no m2 of leaf per m2 of ground in each height class
                     ! FIX(SPM,032414) these should be uncommented this and double check

                     if ( DEBUG ) write(iulog,*) 'EDCLMLink 1154 ', currentPatch%elai_profile(1,ft,iv)

                     currentPatch%elai_profile(1,ft,iv) = currentPatch%tlai_profile(1,ft,iv) * fraction_exposed
                     currentPatch%esai_profile(1,ft,iv) = currentPatch%tsai_profile(1,ft,iv) * fraction_exposed

                     if ( DEBUG ) write(iulog,*) 'EDCLMLink 1159 ', currentPatch%elai_profile(1,ft,iv)

                  enddo ! (iv) hite bins

                  currentCohort => currentCohort%taller

               enddo !currentCohort 

               !check
               currentPatch%lai = 0._r8
               currentCohort => currentPatch%shortest
               do while(associated(currentCohort)) 
                  currentPatch%lai = currentPatch%lai +currentCohort%lai
                  currentCohort => currentCohort%taller   
               enddo !currentCohort
               lai = 0.0_r8
               do ft = 1,numpft_ed
                  lai = lai+ sum(currentPatch%tlai_profile(1,ft,:))
               enddo

               if(lai > currentPatch%lai)then
                  write(iulog,*) 'ED: problem with lai assignments'
               endif


            else ! smooth leaf distribution  
               !Go through all cohorts and add their leaf area and canopy area to the accumulators. 
               currentPatch%tlai_profile = 0._r8
               currentPatch%tsai_profile = 0._r8  
               currentPatch%elai_profile = 0._r8
               currentPatch%esai_profile = 0._r8 
               currentPatch%layer_height_profile = 0._r8
               currentPatch%canopy_area_profile(:,:,:) = 0._r8       
               currentPatch%ncan(:,:) = 0 
               currentPatch%nrad(:,:) = 0 
               currentCohort => currentPatch%shortest

               do while(associated(currentCohort))   
                  L = currentCohort%canopy_layer
                  ft = currentCohort%pft 
                  !Calculate the number of layers of thickness dlai, including the last one. 
                  currentCohort%NV =  CEILING((currentCohort%treelai+currentCohort%treesai)/dinc_ed)
                  !how much of each tree is stem area index? Assuming that there is 
                  if(currentCohort%treelai+currentCohort%treesai > 0._r8)then    
                     fleaf = currentCohort%lai / (currentCohort%lai + currentCohort%sai) 
                  else
                     fleaf = 0._r8
                     write(iulog,*) 'ED: no stem or leaf area' ,currentCohort%pft,currentCohort%bl, &
                          currentCohort%balive,currentCohort%treelai,currentCohort%treesai,currentCohort%dbh, &
                          currentCohort%n,currentCohort%status_coh
                  endif
                  currentPatch%ncan(L,ft) = max(currentPatch%ncan(L,ft),currentCohort%NV)  
                  currentPatch%nrad(L,ft) = currentPatch%ncan(L,ft)  !fudge - this needs to be altered for snow burial
                  if(currentCohort%NV > currentPatch%nrad(L,ft))then
                     write(iulog,*) 'ED: issue with NV',currentCohort%NV,currentCohort%pft,currentCohort%canopy_layer
                  endif

                  ! c = clmpatch%column(currentPatch%clm_pno)
                  ! INTERF-TODO: REMOVE THIS AT SOME POINT, THIS SANITY CHECK IS NOT NEEDED WHEN THE
                  ! COLUMNIZATION IS COMPLETE
                  if( clmpatch%column(currentPatch%clm_pno) .ne. colindex .or. currentPatch%clm_pno .ne. p )then
                     ! ERROR
                     write(iulog,*) ' clmpatch%column(currentPatch%clm_pno) .ne. colindex .or. currentPatch%clm_pno .ne. p '
                     call endrun(msg=errMsg(__FILE__, __LINE__))
                  end if


                  !Whole layers.  Make a weighted average of the leaf area in each layer before dividing it by the total area. 
                  !fill up layer for whole layers.  FIX(RF,032414)- for debugging jan 2012
                  do iv = 1,currentCohort%NV-1 

                     ! what is the height of this layer? (for snow burial purposes...)  
                     ! pftcon%vertical_canopy_frac(ft))! fudge - this should be pft specific but i cant get it to compile. 
                     layer_top_hite = currentCohort%hite-((iv/currentCohort%NV) * currentCohort%hite * &
                          EDecophyscon%crown(currentCohort%pft) )
                     layer_bottom_hite = currentCohort%hite-(((iv+1)/currentCohort%NV) * currentCohort%hite * &
                          EDecophyscon%crown(currentCohort%pft)) ! pftcon%vertical_canopy_frac(ft))
                 
                     write(*,*) 'calc snow 2', colindex, snow_depth(colindex) , frac_sno_eff(colindex)
                     ! fraction_exposed = 1.0_r8 !default. 
              
      !  snow_depth_col = snow_depth(c) ! * frac_sno_eff(c)
      !               if(snow_depth_col  > layer_top_hite)then
      !                  fraction_exposed = 0._r8
      !               endif
      !               if(snow_depth_col < layer_bottom_hite)then
      !                 fraction_exposed = 1._r8
      !               endif
      !               if(snow_depth_col>= layer_bottom_hite.and.snow_depth_col <= layer_top_hite)then !only partly hidden...                        
 	!		              fraction_exposed =  max(0._r8,(min(1.0_r8,(snow_depth_col-layer_bottom_hite)/ &
   !                          (layer_top_hite-layer_bottom_hite ))))
   !                  endif
fraction_exposed =1.0_r8

                     currentPatch%tlai_profile(L,ft,iv) = currentPatch%tlai_profile(L,ft,iv)+ dinc_ed * fleaf * &
                          currentCohort%c_area/currentPatch%total_canopy_area
                     currentPatch%elai_profile(L,ft,iv) = currentPatch%elai_profile(L,ft,iv)+ dinc_ed * fleaf * &
                          currentCohort%c_area/currentPatch%total_canopy_area * fraction_exposed
                     
                     currentPatch%tsai_profile(L,ft,iv) = currentPatch%tsai_profile(L,ft,iv)+ dinc_ed * (1._r8 - fleaf) * &
                          currentCohort%c_area/currentPatch%total_canopy_area
                     currentPatch%esai_profile(L,ft,iv) = currentPatch%esai_profile(L,ft,iv)+ dinc_ed * (1._r8 - fleaf) * &
                          currentCohort%c_area/currentPatch%total_canopy_area * fraction_exposed
                     
                     currentPatch%canopy_area_profile(L,ft,iv) =  min(1.0_r8,currentPatch%canopy_area_profile(L,ft,iv) + &
                          currentCohort%c_area/currentPatch%total_canopy_area)
                     currentPatch%layer_height_profile(L,ft,iv) = currentPatch%layer_height_profile(L,ft,iv) + (dinc_ed * fleaf * &
                          currentCohort%c_area/currentPatch%total_canopy_area *(layer_top_hite+layer_bottom_hite)/2.0_r8) !average height of layer. 
                     
                    write(*,*) 'LHP', currentPatch%layer_height_profile(L,ft,iv)
                     if ( DEBUG ) write(iulog,*) 'EDCLMLink 1246 ', currentPatch%elai_profile(1,ft,iv)

                  end do
                  
                  !Bottom layer
                  iv = currentCohort%NV
                  ! pftcon%vertical_canopy_frac(ft))! fudge - this should be pft specific but i cant get it to compile.
                  layer_top_hite = currentCohort%hite-((iv/currentCohort%NV) * currentCohort%hite * &
                       EDecophyscon%crown(currentCohort%pft) )
                  ! pftcon%vertical_canopy_frac(ft))
                  layer_bottom_hite = currentCohort%hite-(((iv+1)/currentCohort%NV) * currentCohort%hite * &
                       EDecophyscon%crown(currentCohort%pft))

!write(*,*) 'calc snow 3', snow_depth(c) , frac_sno_eff(c)
                   fraction_exposed = 1.0_r8 !default. 
                   snow_depth_col = snow_depth(colindex) * frac_sno_eff(colindex)
                     if(snow_depth_col  > layer_top_hite)then
                        fraction_exposed = 0._r8
                     endif
                     if(snow_depth_col < layer_bottom_hite)then
                       fraction_exposed = 1._r8
 
                    endif
                     if(snow_depth_col>= layer_bottom_hite.and.snow_depth_col <= layer_top_hite)then !only partly hidden...                                   
                        fraction_exposed =  max(0._r8,(min(1.0_r8,(snow_depth_col-layer_bottom_hite)/ &
                             (layer_top_hite-layer_bottom_hite ))))
                     endif
fraction_exposed= 1.0_r8


                  remainder = (currentCohort%treelai + currentCohort%treesai) - (dinc_ed*(currentCohort%NV-1))
                  if(remainder > 1.0_r8)then
                     write(iulog,*)'ED: issue with remainder',currentCohort%treelai,currentCohort%treesai,dinc_ed, & 
                          currentCohort%NV
                  endif
                  !assumes that fleaf is unchanging FIX(RF,032414)

                  currentPatch%tlai_profile(L,ft,iv) =  currentPatch%tlai_profile(L,ft,iv)+ remainder * fleaf * &
                       currentCohort%c_area/currentPatch%total_canopy_area
                  currentPatch%elai_profile(L,ft,iv) = currentPatch%elai_profile(L,ft,iv) + remainder * fleaf * &
                       currentCohort%c_area/currentPatch%total_canopy_area * fraction_exposed
                  !assumes that fleaf is unchanging FIX(RF,032414)

                  currentPatch%tsai_profile(L,ft,iv) =  currentPatch%tsai_profile(L,ft,iv)+  remainder * &
                       (1.0_r8-fleaf) * currentCohort%c_area/currentPatch%total_canopy_area
                  currentPatch%esai_profile(L,ft,iv) = currentPatch%esai_profile(L,ft,iv)+  remainder * &
                       (1.0_r8-fleaf) * currentCohort%c_area/currentPatch%total_canopy_area * fraction_exposed
                  
                  currentPatch%canopy_area_profile(L,ft,iv) = min(1.0_r8,currentPatch%canopy_area_profile(L,ft,iv) + &
                       currentCohort%c_area/currentPatch%total_canopy_area)
                  currentPatch%layer_height_profile(L,ft,iv) = currentPatch%layer_height_profile(L,ft,iv) + (remainder * fleaf * &
                       currentCohort%c_area/currentPatch%total_canopy_area*(layer_top_hite+layer_bottom_hite)/2.0_r8)
                        write(*,*) 'LHP', currentPatch%layer_height_profile(L,ft,iv)
                  if(currentCohort%dbh <= 0._r8.or.currentCohort%n == 0._r8)then
                     write(iulog,*) 'ED: dbh or n is zero in clmedlink', currentCohort%dbh,currentCohort%n
                  endif
                  if(currentCohort%pft == 0.or.currentCohort%canopy_trim <= 0._r8)then
                     write(iulog,*) 'ED: PFT or trim is zero in clmedlink',currentCohort%pft,currentCohort%canopy_trim
                  endif
                  if(currentCohort%balive <= 0._r8.or.currentCohort%bl < 0._r8)then
                     write(iulog,*) 'ED: balive is zero in clmedlink',currentCohort%balive,currentCohort%bl
                  endif

                  currentCohort => currentCohort%taller

               enddo !cohort

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     do iv = 1,currentPatch%nrad(L,ft)
                        !account for total canopy area
                        currentPatch%tlai_profile(L,ft,iv) = currentPatch%tlai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                        currentPatch%tsai_profile(L,ft,iv) = currentPatch%tsai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)

                        if ( DEBUG ) write(iulog,*) 'EDCLMLink 1293 ', currentPatch%elai_profile(L,ft,iv)

                        currentPatch%elai_profile(L,ft,iv) = currentPatch%elai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                        currentPatch%esai_profile(L,ft,iv) = currentPatch%esai_profile(L,ft,iv) / &
                             currentPatch%canopy_area_profile(L,ft,iv)
                     currentPatch%layer_height_profile(L,ft,iv) = currentPatch%layer_height_profile(L,ft,iv) &
                     /currentPatch%tlai_profile(L,ft,iv)
                     enddo

                     currentPatch%tlai_profile(L,ft,currentPatch%nrad(L,ft)+1: cp_nlevcan) = 0._r8
                     currentPatch%tsai_profile(L,ft,currentPatch%nrad(L,ft)+1: cp_nlevcan) = 0._r8
                     currentPatch%elai_profile(L,ft,currentPatch%nrad(L,ft)+1: cp_nlevcan) = 0._r8 
                     currentPatch%esai_profile(L,ft,currentPatch%nrad(L,ft)+1: cp_nlevcan) = 0._r8
                     
                  enddo
               enddo

               !what is the resultant leaf area? 



               tlai_temp = 0._r8
!               elai_temp = 0._r8
!               tsai_temp = 0._r8
!               esai_temp = 0._r8

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed

                     tlai_temp = tlai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
                          currentPatch%tlai_profile(L,ft,1:currentPatch%nrad(L,ft)))
 !                    elai_temp = elai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
 !                         currentPatch%elai_profile(L,ft,1:currentPatch%nrad(L,ft)))
 !                    tsai_temp = tsai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
 !                         currentPatch%tsai_profile(L,ft,1:currentPatch%nrad(L,ft)))
 !                    esai_temp = esai_temp + sum(currentPatch%canopy_area_profile(L,ft,1:currentPatch%nrad(L,ft)) * &
 !                         currentPatch%esai_profile(L,ft,1:currentPatch%nrad(L,ft)))
                  enddo
               enddo

               ! This should not had changed
!               p = currentPatch%clm_pno
               if(abs(tlai(p)-tlai_temp) > 0.0001_r8) then

                  write(iulog,*) 'ED: error with tlai calcs',&
                       NC,colindex, abs(tlai(p)-tlai_temp), tlai_temp,tlai(p)

                  do L = 1,currentPatch%NCL_p
                     write(iulog,*) 'ED: carea profile',L,currentPatch%canopy_area_profile(L,1,1:currentPatch%nrad(L,1))
                     write(iulog,*) 'ED: tlai profile',L,currentPatch%tlai_profile(L,1,1:currentPatch%nrad(L,1))
                  end do

               endif

               elai(p) = calc_areaindex(currentPatch,'elai')
               tlai(p) = calc_areaindex(currentPatch,'tlai')
               esai(p) = calc_areaindex(currentPatch,'esai')
               tsai(p) = calc_areaindex(currentPatch,'tsai')

               ! Fraction of vegetation free of snow. What does this do? Is it right? 
               if ((elai(p) + esai(p)) > 0._r8) then
                  frac_veg_nosno_alb(p) = 1.0_r8
               else
                  frac_veg_nosno_alb(p) = 0.0_r8
               end if

               currentPatch%nrad = currentPatch%ncan
               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     if(currentPatch%nrad(L,ft) > 30)then
                        write(iulog,*) 'ED: issue w/ nrad'
                     endif
                     currentPatch%present(L,ft) = 0
                     do  iv = 1, currentPatch%nrad(L,ft);
                        if(currentPatch%canopy_area_profile(L,ft,iv) > 0._r8)then
                           currentPatch%present(L,ft) = 1     
                        endif
                     end do !iv
                  enddo !ft

                  if ( L == 1 .and. abs(sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))) < 0.99999  &
                       .and. currentPatch%NCL_p > 1 ) then
                     write(iulog,*) 'ED: canopy area too small',sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))
                     write(iulog,*) 'ED: cohort areas', currentPatch%canopy_area_profile(1,1:numpft_ed,:)
                  endif

                  if (L == 1 .and. currentPatch%NCL_p > 1 .and.  &
                       abs(sum(currentPatch%canopy_area_profile(1,1:numpft_ed,1))) < 0.99999) then
                     write(iulog,*) 'ED: not enough area in the top canopy', &
                          sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1)), &
                          currentPatch%canopy_area_profile(L,1:numpft_ed,1)
                  endif

                  if(abs(sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1))) > 1.00001)then
                     write(iulog,*) 'ED: canopy-area-profile wrong',sum(currentPatch%canopy_area_profile(L,1:numpft_ed,1)), &
                          colindex,currentPatch%patchno,L
                     write(iulog,*) 'ED: areas',currentPatch%canopy_area_profile(L,1:2,1),currentPatch%patchno

                     currentCohort => currentPatch%shortest

                     do while(associated(currentCohort))

                        if(currentCohort%canopy_layer==1)then
                           write(iulog,*) 'ED: cohorts',currentCohort%dbh,currentCohort%c_area, &
                                currentPatch%total_canopy_area,currentPatch%area,currentPatch%canopy_area
                           write(iulog,*) 'ED: fracarea',currentCohort%pft, currentCohort%c_area/currentPatch%total_canopy_area
                        endif

                        currentCohort => currentCohort%taller  

                     enddo !currentCohort
                  endif
               enddo ! loop over L

               do L = 1,currentPatch%NCL_p
                  do ft = 1,numpft_ed
                     if(currentPatch%present(L,FT) > 1)then
                        write(iulog,*) 'ED: present issue',currentPatch%clm_pno,L,ft,currentPatch%present(L,FT)
                        currentPatch%present(L,ft) = 1
                     endif
                  enddo
               enddo

            endif !leaf distribution

            currentPatch => currentPatch%younger 

         enddo !patch       

       end associate

  end subroutine ed_clm_leaf_area_profile

  !------------------------------------------------------------------------

  subroutine SummarizeNetFluxes(this, bounds, num_soilc, filter_soilc, &
      sites, nsites, fcolumn, soilbiogeochem_carbonflux_inst, &
      soilbiogeochem_carbonstate_inst)

   ! Summarize the combined production and decomposition fluxes into net fluxes
   ! This is done on the fast timestep, and to be called after both daily ED calls and fast BGC calls
   ! Does not include summarization of fast-timestsp productivity calls because these must be summarized prior to daily ED calls
   !
   ! Written by Charlie Koven, Feb 2016
   !
   ! !USES: 
   use LandunitType         , only : lun
   use landunit_varcon      , only : istsoil
   !
   implicit none   
   !
   ! !ARGUMENTS    
   class(ed_clm_type)                                      :: this  
   type(bounds_type)                       , intent(in)    :: bounds  
   integer                                 , intent(in)    :: num_soilc         ! number of soil columns in filter
   integer                                 , intent(in)    :: filter_soilc(:)   ! filter for soil columns
   type(ed_site_type)                      , intent(in), target :: sites(nsites)
   integer                                 , intent(in)    :: nsites
   integer                                 , intent(in)    :: fcolumn(nsites)
   type(soilbiogeochem_carbonflux_type)    , intent(inout) :: soilbiogeochem_carbonflux_inst
   type(soilbiogeochem_carbonstate_type)   , intent(inout) :: soilbiogeochem_carbonstate_inst
   !
   ! !LOCAL VARIABLES:
   real(r8) :: dt ! radiation time step (seconds)
   integer :: c, s, cc, fc, l, p, pp
   type(ed_site_type), pointer :: cs
   type (ed_patch_type)  , pointer :: currentPatch
   type (ed_cohort_type) , pointer :: currentCohort
!   integer  :: firstsoilpatch(bounds%begg:bounds%endg) ! the first patch in this gridcell that is soil and thus bare... 
   real(r8) :: n_perm2     ! individuals per m2 of the whole column
   
   associate(& 
        hr            => soilbiogeochem_carbonflux_inst%hr_col,      & ! (gC/m2/s) total heterotrophic respiration
        totsomc       => soilbiogeochem_carbonstate_inst%totsomc_col, & ! (gC/m2) total soil organic matter carbon
        totlitc       => soilbiogeochem_carbonstate_inst%totlitc_col, & ! (gC/m2) total litter carbon in BGC pools
        npp_col       => this%npp_col,      &
        nep           => this%nep_col,      &
        fire_c_to_atm => this%fire_c_to_atm_col,      &
        nbp           => this%nbp_col,      &
        totecosysc    => this%totecosysc_col,      &
        totedc    => this%totedc_col,      &
        totbgcc    => this%totbgcc_col,      &
        biomass_stock => this%biomass_stock_col,      &    ! total biomass in gC / m2
        ed_litter_stock    => this%ed_litter_stock_col,      & ! ED litter in gC / m2
        cwd_stock     => this%cwd_stock_col,      &        ! total CWD in gC / m2
        seed_stock    => this%seed_stock_col,     &        ! total seed mass in gC / m2
        ed_to_bgc_this_edts           => this%ed_to_bgc_this_edts_col,      &
        ed_to_bgc_last_edts           => this%ed_to_bgc_last_edts_col,      &
        seed_rain_flux                => this%seed_rain_flux_col            &
        )
     
     ! set time steps
     dt = real( get_step_size(), r8 )
     
     ! zero variables first
     ! column variables
     do c = bounds%begc,bounds%endc
        ! summary flux variables
        fire_c_to_atm(c) = 0._r8
        
        ! summary stock variables
        ed_litter_stock(c) = 0._r8
        cwd_stock(c) = 0._r8
        seed_stock(c) = 0._r8
        biomass_stock(c) = 0._r8
        npp_col(c)       = 0.0_r8
     end do
     
     do s = 1, nsites

        c = fcolumn(s)
        p = col%patchi(c)

        ! map ed site-level fire fluxes to clm column fluxes
        fire_c_to_atm(c) = sites(s)%total_burn_flux_to_atm / ( AREA * SHR_CONST_CDAY * 1.e3_r8)

        currentPatch => sites(s)%oldest_patch
        do while(associated(currentPatch))

           p = p + 1

           ! map litter, CWD, and seed pools to column level
           cwd_stock(c) = cwd_stock(c) + (currentPatch%area / AREA) * (sum(currentPatch%cwd_ag)+ &
                 sum(currentPatch%cwd_bg)) * 1.e3_r8
           ed_litter_stock(c) = ed_litter_stock(c) + (currentPatch%area / AREA) * &
                 (sum(currentPatch%leaf_litter)+sum(currentPatch%root_litter)) * 1.e3_r8
           seed_stock(c)   = seed_stock(c)   + (currentPatch%area / AREA) * sum(currentPatch%seed_bank) * 1.e3_r8
           
           currentCohort => currentPatch%tallest
           do while(associated(currentCohort))
                 
              ! for quantities that are natively at column level or higher, calculate plant density using whole area (for grid cell averages)
              n_perm2   = currentCohort%n/AREA                    
              
              ! map biomass pools to column level
              biomass_stock(c) =  biomass_stock(c) + (currentCohort%bdead + currentCohort%balive + &
                    currentCohort%bstore) * n_perm2 * 1.e3_r8

              npp_col(c) = npp_col(c) + currentCohort%npp_tstep * n_perm2 * 1.e3_r8 /dt

              currentCohort => currentCohort%shorter
           enddo !currentCohort
           currentPatch => currentPatch%younger
        end do ! patch loop
     end do    ! site loop

     ! calculate NEP and NBP fluxes.  ?????
     do fc = 1,num_soilc
        c = filter_soilc(fc)
        nep(c) = npp_col(c) - hr(c)
        nbp(c) = npp_col(c) - ( hr(c) + fire_c_to_atm(c) )
     end do
      
     ! calculate total stocks
     do fc = 1,num_soilc
        c = filter_soilc(fc)
        
        totedc(c) = ed_litter_stock(c) + cwd_stock(c) + seed_stock(c) + biomass_stock(c) ! ED stocks
        totbgcc(c) = totsomc(c) + totlitc(c)  ! BGC stocks
        totecosysc(c) = totedc(c) + totbgcc(c)

     end do

     ! in ED timesteps, because of offset between when ED and BGC reconcile the gain and loss of litterfall carbon,
     ! (i.e. ED reconciles it instantly, while BGC reconciles it incrementally over the subsequent day)
     ! calculate the total ED -> BGC flux and keep track of the last day's info for balance checking purposes
     if ( is_beg_curr_day() ) then
        !
        do s = 1,nsites
           c = fcolumn(s)
           ed_to_bgc_last_edts(c) = ed_to_bgc_this_edts(c)
        end do
        !
        do s = 1,nsites
           c = fcolumn(s)
           ed_to_bgc_this_edts(c) = 0._r8
           seed_rain_flux(c) = 0._r8
        end do
        !
        do s = 1,nsites
           c = fcolumn(s)

           currentPatch => sites(s)%oldest_patch
           do while(associated(currentPatch))
              !
              ed_to_bgc_this_edts(c) = ed_to_bgc_this_edts(c) + (sum(currentPatch%CWD_AG_out) + sum(currentPatch%CWD_BG_out) &
                   + sum(currentPatch%seed_decay) + sum(currentPatch%leaf_litter_out) + sum(currentPatch%root_litter_out)) &
                   * ( currentPatch%area/AREA ) * 1.e3_r8 / ( 365.0_r8*SHR_CONST_CDAY )
              !
              seed_rain_flux(c) = seed_rain_flux(c) + sum(currentPatch%seed_rain_flux) * 1.e3_r8 / ( 365.0_r8*SHR_CONST_CDAY )
              !
              currentPatch => currentPatch%younger
           end do !currentPatch
        end do
     endif

   end associate
   
 end subroutine SummarizeNetFluxes


 subroutine ED_BGC_Carbon_Balancecheck(this, bounds, num_soilc, filter_soilc, soilbiogeochem_carbonflux_inst)  

   ! Integrate in time the fluxes into and out of the ecosystem, and compare these on a daily timestep
   ! to the chagne in carbon stocks of the ecosystem
   !
   ! Written by Charlie Koven, Feb 2016
   !
   ! !USES: 
   !
   implicit none   
   !
   ! !ARGUMENTS    
   class(ed_clm_type)                                      :: this  
   type(bounds_type)                       , intent(in)    :: bounds  
   integer                                 , intent(in)    :: num_soilc         ! number of soil columns in filter
   integer                                 , intent(in)    :: filter_soilc(:)   ! filter for soil columns
   type(soilbiogeochem_carbonflux_type)    , intent(inout) :: soilbiogeochem_carbonflux_inst
   !
   ! !LOCAL VARIABLES:
   real(r8) :: dtime                                     ! land model time step (sec)
   integer  :: nstep                                     ! model timestep
   real(r8) :: nbp_integrated(bounds%begc:bounds%endc)   ! total net biome production integrated
   real(r8) :: error_total(bounds%begc:bounds%endc)
   real(r8) :: error_ed(bounds%begc:bounds%endc)
   real(r8) :: error_bgc(bounds%begc:bounds%endc)
   real(r8) :: error_tolerance = 1.e-6_r8
   real(r8) :: max_error_ed
   real(r8) :: max_error_bgc
   real(r8) :: max_error_total
   integer  :: fc,c

   associate(& 
        nep                 => this%nep_col,                 &
        nep_timeintegrated  => this%nep_timeintegrated_col,  &
        hr                  => soilbiogeochem_carbonflux_inst%hr_col,      &
        hr_timeintegrated   => this%hr_timeintegrated_col,  &
        npp_col          => this%npp_col,      &
        npp_timeintegrated  => this%npp_timeintegrated_col,  &
        fire_c_to_atm       => this%fire_c_to_atm_col,       &
        totecosysc_old      => this%totecosysc_old_col,      &
        totecosysc          => this%totecosysc_col,          &
        totedc_old          => this%totedc_old_col,      &
        totedc              => this%totedc_col,          &
        totbgcc_old         => this%totbgcc_old_col,      &
        totbgcc             => this%totbgcc_col,          &
        ed_to_bgc_this_edts => this%ed_to_bgc_this_edts_col, &
        ed_to_bgc_last_edts => this%ed_to_bgc_last_edts_col, &
        seed_rain_flux      => this%seed_rain_flux_col,  &
        cbalance_error_ed   => this%cbalance_error_ed_col,   &
        cbalance_error_bgc  => this%cbalance_error_bgc_col,  &
        cbalance_error_total=> this%cbalance_error_total_col &
        )

     dtime = get_step_size()
     nstep = get_nstep()

     if (nstep .le. 1) then
        ! when starting up the model, initialize the integrator variables
        do fc = 1,num_soilc
           c = filter_soilc(fc)
           totecosysc_old(c) = totecosysc(c)
           totedc_old(c) = totedc(c)
           totbgcc_old(c) = totbgcc(c)
           nep_timeintegrated(c) = 0._r8
           hr_timeintegrated(c) = 0._r8
           npp_timeintegrated(c) = 0._r8
           !
           ! also initialize the ed-BGC flux variables
           ed_to_bgc_this_edts(c) = 0._r8
           ed_to_bgc_last_edts(c) = 0._r8
           !
           cbalance_error_ed(c) = 0._r8
           cbalance_error_bgc(c) = 0._r8
           cbalance_error_total(c) = 0._r8
        end do        
     endif

     if ( .not. is_beg_curr_day() ) then
        ! on CLM (half-hourly) timesteps, integrate the NEP fluxes        
        do fc = 1,num_soilc
           c = filter_soilc(fc)
           nep_timeintegrated(c) = nep_timeintegrated(c) + nep(c) * dtime
           hr_timeintegrated(c) = hr_timeintegrated(c) + hr(c) * dtime
           npp_timeintegrated(c) = npp_timeintegrated(c) + npp_col(c) * dtime
        end do
     else
        ! on ED (daily) timesteps, first integrate the NEP fluxes and add in the daily disturbance flux
        do fc = 1,num_soilc
           c = filter_soilc(fc)
           nep_timeintegrated(c) = nep_timeintegrated(c) + nep(c) * dtime
           hr_timeintegrated(c) = hr_timeintegrated(c) + hr(c) * dtime
           npp_timeintegrated(c) = npp_timeintegrated(c) + npp_col(c) * dtime
           nbp_integrated(c) = nep_timeintegrated(c) - fire_c_to_atm(c) * SHR_CONST_CDAY + seed_rain_flux(c)* SHR_CONST_CDAY
        end do

        ! next compare the change in carbon and calculate the error
        do fc = 1,num_soilc
           c = filter_soilc(fc)
           error_ed(c) = totedc(c) - totedc_old(c) - (npp_timeintegrated(c) + seed_rain_flux(c)* SHR_CONST_CDAY - ed_to_bgc_this_edts(c)* SHR_CONST_CDAY - fire_c_to_atm(c) * SHR_CONST_CDAY)
           error_bgc(c) = totbgcc(c) - totbgcc_old(c) - (ed_to_bgc_last_edts(c)* SHR_CONST_CDAY - hr_timeintegrated(c))
           error_total(c) = totecosysc(c) - totecosysc_old(c) - (nbp_integrated(c) + ed_to_bgc_last_edts(c)* SHR_CONST_CDAY - ed_to_bgc_this_edts(c)* SHR_CONST_CDAY)
        end do
        !
        ! put in consistent flux units and send to history so we can keep track of the errors
        do fc = 1,num_soilc
           c = filter_soilc(fc)
           cbalance_error_ed(c) = error_ed(c) / SHR_CONST_CDAY
           cbalance_error_bgc(c) = error_bgc(c) / SHR_CONST_CDAY
           cbalance_error_total(c) = error_total(c) / SHR_CONST_CDAY
        end do
        
        ! for now, rather than crashing the model, lets just report the largest error to see what we're up against
        !
        ! RETURN TO THIS LATER AND ADD A CRASHER IF BALANCE EXCEEDS THRESHOLD
        !
        ! max_error_total = 0._r8
        ! do fc = 1,num_soilc
        !    c = filter_soilc(fc)
        !    if (abs(error_total(c)) .gt. max_error_total) then
        !       max_error_ed = abs(error_ed(c))
        !       max_error_bgc = abs(error_bgc(c))
        !       max_error_total = abs(error_total(c))
        !    endif
        ! end do
        ! write(iulog,*) 'ED_BGC_Carbon_Balancecheck: max_error_ed, max_error_bgc, max_error_total (gC / m2 / day): ', max_error_ed, max_error_bgc, max_error_total

        ! reset the C stock and flux integrators
        do fc = 1,num_soilc
           c = filter_soilc(fc)
           totecosysc_old(c) = totecosysc(c)
           totedc_old(c)     = totedc(c)
           totbgcc_old(c)    = totbgcc(c)
           nep_timeintegrated(c) = 0._r8
           npp_timeintegrated(c) = 0._r8
           hr_timeintegrated(c) = 0._r8
        end do

     endif

  end associate

 end subroutine ED_BGC_Carbon_Balancecheck
  
end module EDCLMLinkMod
